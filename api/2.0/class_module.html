<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>InspIRCd: Module Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InspIRCd
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_module-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Module Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="modules_8h_source.html">modules.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Module:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_module.png" usemap="#Module_map" alt=""/>
  <map id="Module_map" name="Module_map">
<area href="classclassbase.html" alt="classbase" shape="rect" coords="0,0,158,24"/>
<area href="classusecountbase.html" alt="usecountbase" shape="rect" coords="168,0,326,24"/>
<area href="class_command_module.html" alt="CommandModule&lt; Cmd &gt;" shape="rect" coords="84,112,242,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5a240a8a9ab1813b17bcb810b24ceaea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5a240a8a9ab1813b17bcb810b24ceaea">Module</a> ()</td></tr>
<tr class="separator:a5a240a8a9ab1813b17bcb810b24ceaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19e59816d97db07363143c859ad0c10"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab19e59816d97db07363143c859ad0c10">init</a> ()</td></tr>
<tr class="separator:ab19e59816d97db07363143c859ad0c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf4e278594597a19264689a2d14bde0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_cull_result.html">CullResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a9cf4e278594597a19264689a2d14bde0">cull</a> ()</td></tr>
<tr class="separator:a9cf4e278594597a19264689a2d14bde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9d9c096786d127590fdd8aa2b7d681"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7c9d9c096786d127590fdd8aa2b7d681">~Module</a> ()</td></tr>
<tr class="separator:a7c9d9c096786d127590fdd8aa2b7d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a2018354cc3e7d01d2ef73fbb95407"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88a2018354cc3e7d01d2ef73fbb95407"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Prioritize</b> ()</td></tr>
<tr class="separator:a88a2018354cc3e7d01d2ef73fbb95407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1cba59ac54d26b4649858b2cfc6aa8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_version.html">Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ace1cba59ac54d26b4649858b2cfc6aa8">GetVersion</a> ()=0</td></tr>
<tr class="separator:ace1cba59ac54d26b4649858b2cfc6aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3910edd1a48dfe4db141b04157627a8e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a3910edd1a48dfe4db141b04157627a8e">OnUserConnect</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:a3910edd1a48dfe4db141b04157627a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467945d27be3edec8fbd0de9a37a0c31"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a467945d27be3edec8fbd0de9a37a0c31">OnUserQuit</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;message, const std::string &amp;oper_message)</td></tr>
<tr class="separator:a467945d27be3edec8fbd0de9a37a0c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193075c27aee23eb8baf613ed31327b4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a193075c27aee23eb8baf613ed31327b4">OnUserDisconnect</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:a193075c27aee23eb8baf613ed31327b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f0a0386640538a817ab4b461d75dba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a90f0a0386640538a817ab4b461d75dba">OnChannelPreDelete</a> (<a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="separator:a90f0a0386640538a817ab4b461d75dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6be01493bcae74002a9e81d3ba3473"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a4c6be01493bcae74002a9e81d3ba3473">OnChannelDelete</a> (<a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="separator:a4c6be01493bcae74002a9e81d3ba3473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e65c3401aff9a6c68e2b2f9f2de5dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ae4e65c3401aff9a6c68e2b2f9f2de5dd">OnUserJoin</a> (<a class="el" href="class_membership.html">Membership</a> *memb, bool sync, bool created, CUList &amp;except_list)</td></tr>
<tr class="separator:ae4e65c3401aff9a6c68e2b2f9f2de5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3be3a9518b0ee13a391ae6daffa5553"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af3be3a9518b0ee13a391ae6daffa5553">OnPostJoin</a> (<a class="el" href="class_membership.html">Membership</a> *memb)</td></tr>
<tr class="separator:af3be3a9518b0ee13a391ae6daffa5553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100db8d416d1484716999076880f63d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a100db8d416d1484716999076880f63d5">OnUserPart</a> (<a class="el" href="class_membership.html">Membership</a> *memb, std::string &amp;partmessage, CUList &amp;except_list)</td></tr>
<tr class="separator:a100db8d416d1484716999076880f63d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390969a3664c10646dfe13be95ac016d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a390969a3664c10646dfe13be95ac016d">OnPreRehash</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;parameter)</td></tr>
<tr class="separator:a390969a3664c10646dfe13be95ac016d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae6d16d1fe5d629dce9deedaa0a1b49"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aaae6d16d1fe5d629dce9deedaa0a1b49">OnModuleRehash</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;parameter)</td></tr>
<tr class="separator:aaae6d16d1fe5d629dce9deedaa0a1b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214c9dcd9bbc331697d4ed7ccd173f58"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a214c9dcd9bbc331697d4ed7ccd173f58">OnRehash</a> (<a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="separator:a214c9dcd9bbc331697d4ed7ccd173f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d39c9fabab9dea701f4a3ad2cfff37b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7d39c9fabab9dea701f4a3ad2cfff37b">OnSendSnotice</a> (char &amp;snomask, std::string &amp;type, const std::string &amp;message)</td></tr>
<tr class="separator:a7d39c9fabab9dea701f4a3ad2cfff37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bd372d9510aaeb1181e75295924649"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aa3bd372d9510aaeb1181e75295924649">OnUserPreJoin</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const char *cname, std::string &amp;privs, const std::string &amp;keygiven)</td></tr>
<tr class="separator:aa3bd372d9510aaeb1181e75295924649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fb5e86ea38f35095af102f40894c1b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a54fb5e86ea38f35095af102f40894c1b">OnUserPreKick</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_membership.html">Membership</a> *memb, const std::string &amp;reason)</td></tr>
<tr class="separator:a54fb5e86ea38f35095af102f40894c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0c7ca18eadf768e69894f2995b0db7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a0a0c7ca18eadf768e69894f2995b0db7">OnUserKick</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_membership.html">Membership</a> *memb, const std::string &amp;reason, CUList &amp;except_list)</td></tr>
<tr class="separator:a0a0c7ca18eadf768e69894f2995b0db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6f7ea0790f23d6c15ff3daf40b7f48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#afb6f7ea0790f23d6c15ff3daf40b7f48">OnOper</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;opertype)</td></tr>
<tr class="separator:afb6f7ea0790f23d6c15ff3daf40b7f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b2ffd9df24552ff78888a536faceba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ac0b2ffd9df24552ff78888a536faceba">OnPostOper</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;opername, const std::string &amp;opertype)</td></tr>
<tr class="separator:ac0b2ffd9df24552ff78888a536faceba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af351dba33f01a510e4b98ebe76efa452"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af351dba33f01a510e4b98ebe76efa452">OnInfo</a> (<a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="separator:af351dba33f01a510e4b98ebe76efa452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450dc0c85646c5286f1c84f2c2d1ed14"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a450dc0c85646c5286f1c84f2c2d1ed14">OnWhois</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest)</td></tr>
<tr class="separator:a450dc0c85646c5286f1c84f2c2d1ed14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2b1fed6b47eda0305f04426db05baf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a9c2b1fed6b47eda0305f04426db05baf">OnUserPreInvite</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, <a class="el" href="class_channel.html">Channel</a> *channel, time_t timeout)</td></tr>
<tr class="separator:a9c2b1fed6b47eda0305f04426db05baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab317fe70e3a528ad41c43f5cb3e252a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab317fe70e3a528ad41c43f5cb3e252a7">OnUserInvite</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, <a class="el" href="class_channel.html">Channel</a> *channel, time_t timeout)</td></tr>
<tr class="separator:ab317fe70e3a528ad41c43f5cb3e252a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6982393c29ffcd698dc42e345fbd9d84"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a6982393c29ffcd698dc42e345fbd9d84">OnUserPreMessage</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, std::string &amp;text, char status, CUList &amp;exempt_list)</td></tr>
<tr class="separator:a6982393c29ffcd698dc42e345fbd9d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1daccd21f78e44a5855d916d35873628"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a1daccd21f78e44a5855d916d35873628">OnUserPreNotice</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, std::string &amp;text, char status, CUList &amp;exempt_list)</td></tr>
<tr class="separator:a1daccd21f78e44a5855d916d35873628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67613e4e1a90b89b689911fa6d933b0e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a67613e4e1a90b89b689911fa6d933b0e">OnBuildNeighborList</a> (<a class="el" href="class_user.html">User</a> *source, UserChanList &amp;include_c, std::map&lt; <a class="el" href="class_user.html">User</a> *, bool &gt; &amp;exceptions)</td></tr>
<tr class="separator:a67613e4e1a90b89b689911fa6d933b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c0588d2b9536f3ac984745cfe9fe0c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a14c0588d2b9536f3ac984745cfe9fe0c">OnUserPreNick</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;newnick)</td></tr>
<tr class="separator:a14c0588d2b9536f3ac984745cfe9fe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c261f2aa608ecdad8ae704734505f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a57c261f2aa608ecdad8ae704734505f7">OnUserMessage</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, const std::string &amp;text, char status, const CUList &amp;exempt_list)</td></tr>
<tr class="separator:a57c261f2aa608ecdad8ae704734505f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7e309f4ac701329acdc0b5600ee678"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a0a7e309f4ac701329acdc0b5600ee678">OnUserNotice</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, const std::string &amp;text, char status, const CUList &amp;exempt_list)</td></tr>
<tr class="separator:a0a7e309f4ac701329acdc0b5600ee678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19baf615db55e3363cd3065674fc3b72"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a19baf615db55e3363cd3065674fc3b72">OnText</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, const std::string &amp;text, char status, CUList &amp;exempt_list)</td></tr>
<tr class="separator:a19baf615db55e3363cd3065674fc3b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af616c7db4ddd687f0402a0d94ab998f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af616c7db4ddd687f0402a0d94ab998f7">OnMode</a> (<a class="el" href="class_user.html">User</a> *user, void *dest, int target_type, const std::vector&lt; std::string &gt; &amp;text, const std::vector&lt; TranslateType &gt; &amp;translate)</td></tr>
<tr class="separator:af616c7db4ddd687f0402a0d94ab998f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73942a4fa3c80fcee0fbbe501aeae20"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ad73942a4fa3c80fcee0fbbe501aeae20">OnGetServerDescription</a> (const std::string &amp;servername, std::string &amp;description)</td></tr>
<tr class="separator:ad73942a4fa3c80fcee0fbbe501aeae20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0d58aeef06736a367072e593116ce0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aeb0d58aeef06736a367072e593116ce0">OnSyncUser</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_module.html">Module</a> *proto, void *opaque)</td></tr>
<tr class="separator:aeb0d58aeef06736a367072e593116ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6ddca119f70f61a24e77b7efdeea07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a4f6ddca119f70f61a24e77b7efdeea07">OnSyncChannel</a> (<a class="el" href="class_channel.html">Channel</a> *chan, <a class="el" href="class_module.html">Module</a> *proto, void *opaque)</td></tr>
<tr class="separator:a4f6ddca119f70f61a24e77b7efdeea07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b15ff09476c1edb53ecadae0cbf57ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b15ff09476c1edb53ecadae0cbf57ac"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>OnSyncNetwork</b> (<a class="el" href="class_module.html">Module</a> *proto, void *opaque)</td></tr>
<tr class="separator:a8b15ff09476c1edb53ecadae0cbf57ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e2a4e731ead980507fd02e0b1f69b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af2e2a4e731ead980507fd02e0b1f69b0">OnDecodeMetaData</a> (<a class="el" href="class_extensible.html">Extensible</a> *target, const std::string &amp;extname, const std::string &amp;extdata)</td></tr>
<tr class="separator:af2e2a4e731ead980507fd02e0b1f69b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0861ead2131a6edbb77bf4be1d2104ad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a0861ead2131a6edbb77bf4be1d2104ad">ProtoSendMode</a> (void *opaque, TargetTypeFlags target_type, void *target, const std::vector&lt; std::string &gt; &amp;modeline, const std::vector&lt; TranslateType &gt; &amp;translate)</td></tr>
<tr class="separator:a0861ead2131a6edbb77bf4be1d2104ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb9dac5417ed8538e5174ebafd25e12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a3bb9dac5417ed8538e5174ebafd25e12">ProtoSendMetaData</a> (void *opaque, <a class="el" href="class_extensible.html">Extensible</a> *target, const std::string &amp;extname, const std::string &amp;extdata)</td></tr>
<tr class="separator:a3bb9dac5417ed8538e5174ebafd25e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76e89f05626000f80f205db32671d56"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aa76e89f05626000f80f205db32671d56">OnWallops</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;text)</td></tr>
<tr class="separator:aa76e89f05626000f80f205db32671d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6aa4ebe19c22eb32f7a65ecbc74594"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a9f6aa4ebe19c22eb32f7a65ecbc74594">OnChangeHost</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;newhost)</td></tr>
<tr class="separator:a9f6aa4ebe19c22eb32f7a65ecbc74594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d41b8806e963af21486007e5f8369c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a1d41b8806e963af21486007e5f8369c3">OnChangeName</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;gecos)</td></tr>
<tr class="separator:a1d41b8806e963af21486007e5f8369c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135ab5a74a236dc4f696191b25efec2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a135ab5a74a236dc4f696191b25efec2b">OnChangeIdent</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;ident)</td></tr>
<tr class="separator:a135ab5a74a236dc4f696191b25efec2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace17c45466526ac93a24c8a7441b59e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ace17c45466526ac93a24c8a7441b59e3">OnAddLine</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_x_line.html">XLine</a> *line)</td></tr>
<tr class="separator:ace17c45466526ac93a24c8a7441b59e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa784e9b35582872ca8228053c93615d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aa784e9b35582872ca8228053c93615d7">OnDelLine</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_x_line.html">XLine</a> *line)</td></tr>
<tr class="separator:aa784e9b35582872ca8228053c93615d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b8a6dd1c8e6f2e8e15eed14a5205e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a33b8a6dd1c8e6f2e8e15eed14a5205e6">OnExpireLine</a> (<a class="el" href="class_x_line.html">XLine</a> *line)</td></tr>
<tr class="separator:a33b8a6dd1c8e6f2e8e15eed14a5205e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf8e8cec05aff2e6a3c0edb45eedd6d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#afcf8e8cec05aff2e6a3c0edb45eedd6d">OnCleanup</a> (int target_type, void *item)</td></tr>
<tr class="separator:afcf8e8cec05aff2e6a3c0edb45eedd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35164fe098f2acdec99d3e242e585e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ad35164fe098f2acdec99d3e242e585e9">OnUserPostNick</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;oldnick)</td></tr>
<tr class="separator:ad35164fe098f2acdec99d3e242e585e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c3d1cf69b8b43b133ad4bf18e110ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af5c3d1cf69b8b43b133ad4bf18e110ec">OnPreMode</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, <a class="el" href="class_channel.html">Channel</a> *channel, const std::vector&lt; std::string &gt; &amp;parameters)</td></tr>
<tr class="separator:af5c3d1cf69b8b43b133ad4bf18e110ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed6b1b9feca7d107da23aafe1fef9fa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#abed6b1b9feca7d107da23aafe1fef9fa">On005Numeric</a> (std::string &amp;output)</td></tr>
<tr class="separator:abed6b1b9feca7d107da23aafe1fef9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140312a31a1e9163193dd7707707c6b8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a140312a31a1e9163193dd7707707c6b8">OnKill</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, const std::string &amp;reason)</td></tr>
<tr class="separator:a140312a31a1e9163193dd7707707c6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d0823f952be21553f6846617907a36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ac7d0823f952be21553f6846617907a36">OnRemoteKill</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_user.html">User</a> *dest, const std::string &amp;reason, const std::string &amp;operreason)</td></tr>
<tr class="separator:ac7d0823f952be21553f6846617907a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedc27f4e91f68ee71ca14afa91e7145"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#abedc27f4e91f68ee71ca14afa91e7145">OnLoadModule</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="separator:abedc27f4e91f68ee71ca14afa91e7145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55ed63d022db5f011db3d8c03ef6953"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab55ed63d022db5f011db3d8c03ef6953">OnUnloadModule</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="separator:ab55ed63d022db5f011db3d8c03ef6953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22aeb882a4a4cc619ebb7625ae241686"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a22aeb882a4a4cc619ebb7625ae241686">OnBackgroundTimer</a> (time_t curtime)</td></tr>
<tr class="separator:a22aeb882a4a4cc619ebb7625ae241686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678967e0e769ecd295a3a272fa488af3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a678967e0e769ecd295a3a272fa488af3">OnPreCommand</a> (std::string &amp;command, std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_local_user.html">LocalUser</a> *user, bool validated, const std::string &amp;original_line)</td></tr>
<tr class="separator:a678967e0e769ecd295a3a272fa488af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098c9e5b967414eb73f5f1c3eb4952e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a098c9e5b967414eb73f5f1c3eb4952e6">OnPostCommand</a> (const std::string &amp;command, const std::vector&lt; std::string &gt; &amp;parameters, <a class="el" href="class_local_user.html">LocalUser</a> *user, CmdResult result, const std::string &amp;original_line)</td></tr>
<tr class="separator:a098c9e5b967414eb73f5f1c3eb4952e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ed68d2c341e59dd9acc50672d67aae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a45ed68d2c341e59dd9acc50672d67aae">OnUserInit</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:a45ed68d2c341e59dd9acc50672d67aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05531b903581d8100ca28934eac468d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab05531b903581d8100ca28934eac468d">OnCheckReady</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:ab05531b903581d8100ca28934eac468d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee48e5f4d4efbb826f462c1e5f4d0ee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aeee48e5f4d4efbb826f462c1e5f4d0ee">OnUserRegister</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:aeee48e5f4d4efbb826f462c1e5f4d0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6fc87d0e8f6847eee8e216f8026c08"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#afe6fc87d0e8f6847eee8e216f8026c08">OnCheckInvite</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="separator:afe6fc87d0e8f6847eee8e216f8026c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bbfae81a74a9cb3131c3e7c1f3cfe7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a23bbfae81a74a9cb3131c3e7c1f3cfe7">OnRawMode</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const char mode, const std::string &amp;param, bool adding, int pcnt)</td></tr>
<tr class="separator:a23bbfae81a74a9cb3131c3e7c1f3cfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75601f0642212088ae40e38b186595fd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a75601f0642212088ae40e38b186595fd">OnCheckKey</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;keygiven)</td></tr>
<tr class="separator:a75601f0642212088ae40e38b186595fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63e9aa43689a8bac7bb27c39e430d9e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab63e9aa43689a8bac7bb27c39e430d9e">OnCheckLimit</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="separator:ab63e9aa43689a8bac7bb27c39e430d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e86cd99c82307e8c5d19fec3b575d2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a54e86cd99c82307e8c5d19fec3b575d2">OnCheckChannelBan</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan)</td></tr>
<tr class="separator:a54e86cd99c82307e8c5d19fec3b575d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029982a980048c30c5b4dec12886af76"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a029982a980048c30c5b4dec12886af76">OnCheckBan</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;mask)</td></tr>
<tr class="separator:a029982a980048c30c5b4dec12886af76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329aa3d2f888266d347122df7cdab3bc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a329aa3d2f888266d347122df7cdab3bc">OnExtBanCheck</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, char type)</td></tr>
<tr class="separator:a329aa3d2f888266d347122df7cdab3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdbb320fa09ddfc3e17249cf0f057ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a6fdbb320fa09ddfc3e17249cf0f057ec">OnStats</a> (char symbol, <a class="el" href="class_user.html">User</a> *user, string_list &amp;results)</td></tr>
<tr class="separator:a6fdbb320fa09ddfc3e17249cf0f057ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e8a040d752c423103420a814dfc868"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a83e8a040d752c423103420a814dfc868">OnChangeLocalUserHost</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, const std::string &amp;newhost)</td></tr>
<tr class="separator:a83e8a040d752c423103420a814dfc868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcde3dba5bc6c5359b0bbc9964a91a1b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#abcde3dba5bc6c5359b0bbc9964a91a1b">OnChangeLocalUserGECOS</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, const std::string &amp;newhost)</td></tr>
<tr class="separator:abcde3dba5bc6c5359b0bbc9964a91a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0fffc69b3af9695efaec60df2a1876"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aaf0fffc69b3af9695efaec60df2a1876">OnPreTopicChange</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;topic)</td></tr>
<tr class="separator:aaf0fffc69b3af9695efaec60df2a1876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6faca7798ee9ac8a9330c79bacbcd4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a9a6faca7798ee9ac8a9330c79bacbcd4">OnPostTopicChange</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_channel.html">Channel</a> *chan, const std::string &amp;topic)</td></tr>
<tr class="separator:a9a6faca7798ee9ac8a9330c79bacbcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc7ac64df8f7719edf402f27eefc665"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#afcc7ac64df8f7719edf402f27eefc665">OnEvent</a> (<a class="el" href="class_event.html">Event</a> &amp;event)</td></tr>
<tr class="separator:afcc7ac64df8f7719edf402f27eefc665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0478b88aede4d02676433246543eff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7e0478b88aede4d02676433246543eff">OnRequest</a> (<a class="el" href="class_request.html">Request</a> &amp;request)</td></tr>
<tr class="separator:a7e0478b88aede4d02676433246543eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a40bf5ebb638640047a5089e41c333"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab2a40bf5ebb638640047a5089e41c333">OnPassCompare</a> (<a class="el" href="class_extensible.html">Extensible</a> *ex, const std::string &amp;password, const std::string &amp;input, const std::string &amp;hashtype)</td></tr>
<tr class="separator:ab2a40bf5ebb638640047a5089e41c333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7a2974cb000cfcad1f7605a10d3598"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7c7a2974cb000cfcad1f7605a10d3598">OnGlobalOper</a> (<a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="separator:a7c7a2974cb000cfcad1f7605a10d3598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a7c87d002fe32d4d0f46a7f438fbbb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aa3a7c87d002fe32d4d0f46a7f438fbbb">OnPostConnect</a> (<a class="el" href="class_user.html">User</a> *user)</td></tr>
<tr class="separator:aa3a7c87d002fe32d4d0f46a7f438fbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fb27e2d4deeb16da8f0095c647aaf4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a06fb27e2d4deeb16da8f0095c647aaf4">OnAddBan</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_channel.html">Channel</a> *channel, const std::string &amp;banmask)</td></tr>
<tr class="separator:a06fb27e2d4deeb16da8f0095c647aaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4e5d8a6167d1e9a04308b8ee95bfcf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aca4e5d8a6167d1e9a04308b8ee95bfcf">OnDelBan</a> (<a class="el" href="class_user.html">User</a> *source, <a class="el" href="class_channel.html">Channel</a> *channel, const std::string &amp;banmask)</td></tr>
<tr class="separator:aca4e5d8a6167d1e9a04308b8ee95bfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61637539d66530e74cac9de0bb3e408c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a61637539d66530e74cac9de0bb3e408c">OnHookIO</a> (<a class="el" href="class_stream_socket.html">StreamSocket</a> *user, <a class="el" href="class_listen_socket.html">ListenSocket</a> *via)</td></tr>
<tr class="separator:a61637539d66530e74cac9de0bb3e408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7947eef29c1aa49f6f935f60bf313ac2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7947eef29c1aa49f6f935f60bf313ac2">OnAcceptConnection</a> (int fd, <a class="el" href="class_listen_socket.html">ListenSocket</a> *sock, <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *client, <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *server)</td></tr>
<tr class="separator:a7947eef29c1aa49f6f935f60bf313ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86748a9b6b0c7d70327f584aa6e3312d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a86748a9b6b0c7d70327f584aa6e3312d">OnStreamSocketAccept</a> (<a class="el" href="class_stream_socket.html">StreamSocket</a> *sock, <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *client, <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *server)</td></tr>
<tr class="separator:a86748a9b6b0c7d70327f584aa6e3312d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfbf68998422b227693e26aadcf9dbd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aecfbf68998422b227693e26aadcf9dbd">OnStreamSocketWrite</a> (<a class="el" href="class_stream_socket.html">StreamSocket</a> *sock, std::string &amp;sendq)</td></tr>
<tr class="separator:aecfbf68998422b227693e26aadcf9dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc646ceff0374f658038bd5eee47ebda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#abc646ceff0374f658038bd5eee47ebda">OnStreamSocketClose</a> (<a class="el" href="class_stream_socket.html">StreamSocket</a> *sock)</td></tr>
<tr class="separator:abc646ceff0374f658038bd5eee47ebda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436071d564fd9240194a7ea43768bda7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a436071d564fd9240194a7ea43768bda7">OnStreamSocketConnect</a> (<a class="el" href="class_stream_socket.html">StreamSocket</a> *sock)</td></tr>
<tr class="separator:a436071d564fd9240194a7ea43768bda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4c72cc4fe3c64df0b7724e7e49d76b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a2d4c72cc4fe3c64df0b7724e7e49d76b">OnStreamSocketRead</a> (<a class="el" href="class_stream_socket.html">StreamSocket</a> *sock, std::string &amp;recvq)</td></tr>
<tr class="separator:a2d4c72cc4fe3c64df0b7724e7e49d76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16f4b39fb1f4353ad2f5d8b652e7425"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab16f4b39fb1f4353ad2f5d8b652e7425">OnSetAway</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;awaymsg)</td></tr>
<tr class="separator:ab16f4b39fb1f4353ad2f5d8b652e7425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4bdaeb323660a3b9120195f8a6cbcb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a6b4bdaeb323660a3b9120195f8a6cbcb">OnWhoisLine</a> (<a class="el" href="class_user.html">User</a> *user, <a class="el" href="class_user.html">User</a> *dest, int &amp;numeric, std::string &amp;text)</td></tr>
<tr class="separator:a6b4bdaeb323660a3b9120195f8a6cbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152a4ce724c1fed088c51c12be43a62b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a152a4ce724c1fed088c51c12be43a62b">OnGarbageCollect</a> ()</td></tr>
<tr class="separator:a152a4ce724c1fed088c51c12be43a62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7c6fc1a66af63568b6a69db294a0df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5a7c6fc1a66af63568b6a69db294a0df">OnSetConnectClass</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user, <a class="el" href="struct_connect_class.html">ConnectClass</a> *myclass)</td></tr>
<tr class="separator:a5a7c6fc1a66af63568b6a69db294a0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405c9943fe759d41055f7341c1d916b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a405c9943fe759d41055f7341c1d916b0">OnRunTestSuite</a> ()</td></tr>
<tr class="separator:a405c9943fe759d41055f7341c1d916b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add927647a8531cced935d19f532fe9de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#add927647a8531cced935d19f532fe9de">OnNamesListItem</a> (<a class="el" href="class_user.html">User</a> *issuer, <a class="el" href="class_membership.html">Membership</a> *item, std::string &amp;prefixes, std::string &amp;nick)</td></tr>
<tr class="separator:add927647a8531cced935d19f532fe9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0203afb10fbe91ec50b3babf56cd6e2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0203afb10fbe91ec50b3babf56cd6e2f"></a>
virtual <a class="el" href="struct_mod_result.html">ModResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OnNumeric</b> (<a class="el" href="class_user.html">User</a> *user, unsigned int numeric, const std::string &amp;text)</td></tr>
<tr class="separator:a0203afb10fbe91ec50b3babf56cd6e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced8dd06b3db2733ac012b490a84254e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aced8dd06b3db2733ac012b490a84254e">OnSendWhoLine</a> (<a class="el" href="class_user.html">User</a> *source, const std::vector&lt; std::string &gt; &amp;params, <a class="el" href="class_user.html">User</a> *user, std::string &amp;line)</td></tr>
<tr class="separator:aced8dd06b3db2733ac012b490a84254e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9edd94c35056b40d076acf56c6afa0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a3d9edd94c35056b40d076acf56c6afa0">OnSetUserIP</a> (<a class="el" href="class_local_user.html">LocalUser</a> *user)</td></tr>
<tr class="separator:a3d9edd94c35056b40d076acf56c6afa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classusecountbase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classusecountbase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classusecountbase.html">usecountbase</a></td></tr>
<tr class="memitem:a45fc20645148e861a3ffcb6ae769b3f5 inherit pub_methods_classusecountbase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45fc20645148e861a3ffcb6ae769b3f5"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>GetUseCount</b> () const </td></tr>
<tr class="separator:a45fc20645148e861a3ffcb6ae769b3f5 inherit pub_methods_classusecountbase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd838d750d44a4c15fb490a3d42e30e inherit pub_methods_classusecountbase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdd838d750d44a4c15fb490a3d42e30e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>refcount_inc</b> () const </td></tr>
<tr class="separator:afdd838d750d44a4c15fb490a3d42e30e inherit pub_methods_classusecountbase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194edb7376fcb2bd38ed14ca87220fbe inherit pub_methods_classusecountbase"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a194edb7376fcb2bd38ed14ca87220fbe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>refcount_dec</b> () const </td></tr>
<tr class="separator:a194edb7376fcb2bd38ed14ca87220fbe inherit pub_methods_classusecountbase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4b9d41041b7b56a786064020e9c50c75"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a4b9d41041b7b56a786064020e9c50c75">ModuleSourceFile</a></td></tr>
<tr class="separator:a4b9d41041b7b56a786064020e9c50c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbdc3c59248520549e5904bb402e2cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_d_l_l_manager.html">DLLManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5bbdc3c59248520549e5904bb402e2cb">ModuleDLLManager</a></td></tr>
<tr class="separator:a5bbdc3c59248520549e5904bb402e2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab94177da81fe7a68f37e48a554e272f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aab94177da81fe7a68f37e48a554e272f">dying</a></td></tr>
<tr class="separator:aab94177da81fe7a68f37e48a554e272f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for all <a class="el" href="class_insp_i_r_cd.html">InspIRCd</a> modules This class is the base class for <a class="el" href="class_insp_i_r_cd.html">InspIRCd</a> modules. All modules must inherit from this class, its methods will be called when irc server events occur. class inherited from module must be instantiated by the ModuleFactory class (see relevent section) for the module to be initialised. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5a240a8a9ab1813b17bcb810b24ceaea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Module::Module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Creates a module class. Don't do any type of hook registration or checks for other modules here; do that in <a class="el" href="class_module.html#ab19e59816d97db07363143c859ad0c10">init()</a>. </p>

</div>
</div>
<a class="anchor" id="a7c9d9c096786d127590fdd8aa2b7d681"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Module::~Module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default destructor. destroys a module class </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9cf4e278594597a19264689a2d14bde0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cull_result.html">CullResult</a> Module::cull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clean up prior to destruction If you override, you must call this AFTER your module's cleanup </p>

<p>Reimplemented from <a class="el" href="classclassbase.html#a2a773ec2f42d047e0ce250553f44d831">classbase</a>.</p>

</div>
</div>
<a class="anchor" id="ace1cba59ac54d26b4649858b2cfc6aa8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_version.html">Version</a> Module::GetVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the version number of a <a class="el" href="class_module.html">Module</a>. The method should return a <a class="el" href="class_version.html">Version</a> object with its version information assigned via <a class="el" href="class_version.html#aaf3a196a2f6e05adc2dfb92844adcf73">Version::Version</a> </p>

<p>Implemented in <a class="el" href="class_command_module.html#a563725dfafbcb73491f148cd84c04a2e">CommandModule&lt; Cmd &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab19e59816d97db07363143c859ad0c10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Module::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_module.html">Module</a> setup </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_module_exception.html">ModuleException</a></td><td>Throwing this class, or any class derived from <a class="el" href="class_module_exception.html">ModuleException</a>, causes loading of the module to abort. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_command_module.html#a9ee6cd2be5c3ad0bcec0e0cbfc67ef28">CommandModule&lt; Cmd &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abed6b1b9feca7d107da23aafe1fef9fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::On005Numeric </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a 005 numeric is about to be output. The module should modify the 005 numeric if needed to indicate its features. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The 005 string to be modified if neccessary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7947eef29c1aa49f6f935f60bf313ac2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnAcceptConnection </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_listen_socket.html">ListenSocket</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *&#160;</td>
          <td class="paramname"><em>server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a port accepts a connection Return MOD_RES_ACCEPT if you have used the file descriptor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor returned from accept() </td></tr>
    <tr><td class="paramname">sock</td><td>The socket connection for the new user </td></tr>
    <tr><td class="paramname">client</td><td>The client IP address and port </td></tr>
    <tr><td class="paramname">server</td><td>The server IP address and port </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06fb27e2d4deeb16da8f0095c647aaf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnAddBan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>banmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a ban is added to a channel's list. Return a non-zero value to 'eat' the mode change and prevent the ban from being added. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user adding the ban </td></tr>
    <tr><td class="paramname">channel</td><td>The channel the ban is being added to </td></tr>
    <tr><td class="paramname">banmask</td><td>The ban mask being added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to block the ban, 0 to continue as normal </dd></dl>

</div>
</div>
<a class="anchor" id="ace17c45466526ac93a24c8a7441b59e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnAddLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_line.html">XLine</a> *&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever an xline is added by a local user. This method is triggered after the line is added. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The sender of the line or NULL for local server </td></tr>
    <tr><td class="paramname">line</td><td>The xline being added </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a22aeb882a4a4cc619ebb7625ae241686"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnBackgroundTimer </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>curtime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called once every five seconds for background processing. This timer can be used to control timed features. Its period is not accurate enough to be used as a clock, but it is gauranteed to be called at least once in any five second period, directly from the main loop of the server. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curtime</td><td>The current timer derived from time(2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67613e4e1a90b89b689911fa6d933b0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnBuildNeighborList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UserChanList &amp;&#160;</td>
          <td class="paramname"><em>include_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="class_user.html">User</a> *, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>exceptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when sending a message to all "neighbors" of a given user - that is, all users that share a common channel. This is used in commands such as NICK, QUIT, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source of the message </td></tr>
    <tr><td class="paramname">include_c</td><td>Channels to scan for users to include </td></tr>
    <tr><td class="paramname">exceptions</td><td>Map of user-&gt;bool that overrides the inclusion decision</td></tr>
  </table>
  </dd>
</dl>
<p>Set exceptions[user] = true to include, exceptions[user] = false to exclude </p>

</div>
</div>
<a class="anchor" id="a9f6aa4ebe19c22eb32f7a65ecbc74594"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnChangeHost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's hostname is changed. This event triggers after the host has been set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user whos host is being changed </td></tr>
    <tr><td class="paramname">newhost</td><td>The new hostname being set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a135ab5a74a236dc4f696191b25efec2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnChangeIdent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ident</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's IDENT is changed. This event triggers after the name has been set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who's IDENT is being changed </td></tr>
    <tr><td class="paramname">ident</td><td>The new IDENT being set on the user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abcde3dba5bc6c5359b0bbc9964a91a1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnChangeLocalUserGECOS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a change of a local users GECOS (fullname field) is attempted. return 1 to deny the name change, or 0 to allow it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user whos GECOS will be changed </td></tr>
    <tr><td class="paramname">newhost</td><td>The new GECOS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to deny the GECOS change, 0 to allow </dd></dl>

</div>
</div>
<a class="anchor" id="a83e8a040d752c423103420a814dfc868"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnChangeLocalUserHost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a change of a local users displayed host is attempted. Return 1 to deny the host change, or 0 to allow it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user whos host will be changed </td></tr>
    <tr><td class="paramname">newhost</td><td>The new hostname </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to deny the host change, 0 to allow </dd></dl>

</div>
</div>
<a class="anchor" id="a1d41b8806e963af21486007e5f8369c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnChangeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gecos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's GECOS (realname) is changed. This event triggers after the name has been set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who's GECOS is being changed </td></tr>
    <tr><td class="paramname">gecos</td><td>The new GECOS being set on the user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c6be01493bcae74002a9e81d3ba3473"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnChannelDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a channel is deleted, either by QUIT, KICK or PART. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>The channel being deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90f0a0386640538a817ab4b461d75dba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnChannelPreDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a channel is about to be deleted </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>The channel being deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer specifying whether or not the channel may be deleted. 0 for yes, 1 for no. </dd></dl>

</div>
</div>
<a class="anchor" id="a029982a980048c30c5b4dec12886af76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnCheckBan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks for a user's match of a single ban </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user to check for match </td></tr>
    <tr><td class="paramname">chan</td><td>The channel on which the match is being checked </td></tr>
    <tr><td class="paramname">mask</td><td>The mask being checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MOD_RES_DENY to mark as banned, MOD_RES_ALLOW to skip the ban check, or MOD_RES_PASSTHRU to check bans normally </dd></dl>

</div>
</div>
<a class="anchor" id="a54e86cd99c82307e8c5d19fec3b575d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnCheckChannelBan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks for a user's ban from the channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user to check </td></tr>
    <tr><td class="paramname">chan</td><td>The channel to check in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MOD_RES_DENY to mark as banned, MOD_RES_ALLOW to skip the ban check, or MOD_RES_PASSTHRU to check bans normally </dd></dl>

</div>
</div>
<a class="anchor" id="afe6fc87d0e8f6847eee8e216f8026c08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnCheckInvite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user joins a channel, to determine if invite checks should go ahead or not. This method will always be called for each join, wether or not the channel is actually +i, and determines the outcome of an if statement around the whole section of invite checking code. return 1 to explicitly allow the join to go ahead or 0 to ignore the event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user joining the channel </td></tr>
    <tr><td class="paramname">chan</td><td>The channel being joined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to explicitly allow the join, 0 to proceed as normal </dd></dl>

</div>
</div>
<a class="anchor" id="a75601f0642212088ae40e38b186595fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnCheckKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keygiven</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user joins a channel, to determine if key checks should go ahead or not. This method will always be called for each join, wether or not the channel is actually +k, and determines the outcome of an if statement around the whole section of key checking code. if the user specified no key, the keygiven string will be a valid but empty value. return 1 to explicitly allow the join to go ahead or 0 to ignore the event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user joining the channel </td></tr>
    <tr><td class="paramname">chan</td><td>The channel being joined </td></tr>
    <tr><td class="paramname">keygiven</td><td>The key given on joining the channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to explicitly allow the join, 0 to proceed as normal </dd></dl>

</div>
</div>
<a class="anchor" id="ab63e9aa43689a8bac7bb27c39e430d9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnCheckLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user joins a channel, to determine if channel limit checks should go ahead or not. This method will always be called for each join, wether or not the channel is actually +l, and determines the outcome of an if statement around the whole section of channel limit checking code. return 1 to explicitly allow the join to go ahead or 0 to ignore the event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user joining the channel </td></tr>
    <tr><td class="paramname">chan</td><td>The channel being joined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to explicitly allow the join, 0 to proceed as normal </dd></dl>

</div>
</div>
<a class="anchor" id="ab05531b903581d8100ca28934eac468d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnCheckReady </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called to check if a user who is connecting can now be allowed to register If any modules return false for this function, the user is held in the waiting state until all modules return true. For example a module which implements ident lookups will continue to return false for a user until their ident lookup is completed. Note that the registration timeout for a user overrides these checks, if the registration timeout is reached, the user is disconnected even if modules report that the user is not ready to connect. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true to indicate readiness, false if otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="afcf8e8cec05aff2e6a3c0edb45eedd6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnCleanup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before your module is unloaded to clean up Extensibles. This method is called once for every user and channel on the network, so that when your module unloads it may clear up any remaining data in the form of Extensibles added using Extensible::Extend(). If the target_type variable is TYPE_USER, then void* item refers to a User*, otherwise it refers to a Channel*. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_type</td><td>The type of item being cleaned </td></tr>
    <tr><td class="paramname">item</td><td>A pointer to the item's class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2e2a4e731ead980507fd02e0b1f69b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnDecodeMetaData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_extensible.html">Extensible</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows module data, sent via ProtoSendMetaData, to be decoded again by a receiving module. Please see src/modules/m_swhois.cpp for a working example of how to use this method call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The Channel* or User* that data should be added to </td></tr>
    <tr><td class="paramname">extname</td><td>The extension name which is being sent </td></tr>
    <tr><td class="paramname">extdata</td><td>The extension data, encoded at the other end by an identical module through OnSyncChannelMetaData or OnSyncUserMetaData </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca4e5d8a6167d1e9a04308b8ee95bfcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnDelBan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>banmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a ban is removed from a channel's list. Return a non-zero value to 'eat' the mode change and prevent the ban from being removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user deleting the ban </td></tr>
    <tr><td class="paramname">channel</td><td>The channel the ban is being deleted from </td></tr>
    <tr><td class="paramname">banmask</td><td>The ban mask being deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to block the unban, 0 to continue as normal </dd></dl>

</div>
</div>
<a class="anchor" id="aa784e9b35582872ca8228053c93615d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnDelLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_x_line.html">XLine</a> *&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever an xline is deleted MANUALLY. See OnExpireLine for expiry. This method is triggered after the line is deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user removing the line or NULL for local server </td></tr>
    <tr><td class="paramname">line</td><td>the line being deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcc7ac64df8f7719edf402f27eefc665"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_event.html">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever an <a class="el" href="class_event.html">Event</a> class is sent to all modules by another module. You should <em>always</em> check the value of <a class="el" href="class_event.html#a8566f6b1af844306a135e4bc2d2cad62">Event::id</a> to determine the event type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The <a class="el" href="class_event.html">Event</a> class being received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33b8a6dd1c8e6f2e8e15eed14a5205e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnExpireLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_x_line.html">XLine</a> *&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever an xline expires. This method is triggered after the line is deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>The line being deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a329aa3d2f888266d347122df7cdab3bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnExtBanCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks for a match on a given extban type </p><dl class="section return"><dt>Returns</dt><dd>MOD_RES_DENY to mark as banned, MOD_RES_ALLOW to skip the ban check, or MOD_RES_PASSTHRU to check bans normally </dd></dl>

</div>
</div>
<a class="anchor" id="a152a4ce724c1fed088c51c12be43a62b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnGarbageCollect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called at intervals for modules to garbage-collect any hashes etc. Certain data types such as hash_map 'leak' buckets, which must be tidied up and freed by copying into a new item every so often. This method is called when it is time to do that. </p>

</div>
</div>
<a class="anchor" id="ad73942a4fa3c80fcee0fbbe501aeae20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnGetServerDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>servername</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows modules to alter or create server descriptions Whenever a module requires a server description, for example for display in WHOIS, this function is called in all modules. You may change or define the description given in std::string &amp;description. If you do, this description will be shown in the WHOIS fields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">servername</td><td>The servername being searched for </td></tr>
    <tr><td class="paramname">description</td><td>Alterable server description for this server </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c7a2974cb000cfcad1f7605a10d3598"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnGlobalOper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is given usermode +o, anywhere on the network. You cannot override this and prevent it from happening as it is already happened and such a task must be performed by another server. You can however bounce modes by sending servermodes out to reverse mode changes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is opering </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61637539d66530e74cac9de0bb3e408c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnHookIO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_stream_socket.html">StreamSocket</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_listen_socket.html">ListenSocket</a> *&#160;</td>
          <td class="paramname"><em>via</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called to install an I/O hook on an event handler </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The socket to possibly install the I/O hook on </td></tr>
    <tr><td class="paramname">via</td><td>The port that the user connected on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af351dba33f01a510e4b98ebe76efa452"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user types /INFO. The <a class="el" href="class_user.html">User</a> will contain the information of the user who typed the command. Modules may use this method to output their own credits in /INFO (which is the ircd's version of an about box). It is purposefully not possible to modify any info that has already been output, or halt the list. You must write a 371 numeric to the user, containing your info in the following format:</p>
<p>&lt;nick&gt; :information here</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user issuing /INFO </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a140312a31a1e9163193dd7707707c6b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnKill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a client is disconnected by KILL. If a client is killed by a server, e.g. a nickname collision or protocol error, source is NULL. Return 1 from this function to prevent the kill, and 0 from this function to allow it as normal. If you prevent the kill no output will be sent to the client, it is down to your module to generate this information. NOTE: It is NOT advisable to stop kills which originate from servers or remote users. If you do so youre risking race conditions, desyncs and worse! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user sending the KILL </td></tr>
    <tr><td class="paramname">dest</td><td>The user being killed </td></tr>
    <tr><td class="paramname">reason</td><td>The kill reason </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to prevent the kill, 0 to allow </dd></dl>

</div>
</div>
<a class="anchor" id="abedc27f4e91f68ee71ca14afa91e7145"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnLoadModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a module is loaded. mod will contain a pointer to the module, and string will contain its name, for example m_widgets.so. This function is primary for dependency checking, your module may decide to enable some extra features if it sees that you have for example loaded "m_killwidgets.so" with "m_makewidgets.so". It is highly recommended that modules do <em>NOT</em> bail if they cannot satisfy dependencies, but instead operate under reduced functionality, unless the dependency is absolutely neccessary (e.g. a module that extends the features of another module). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>A pointer to the new module </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af616c7db4ddd687f0402a0d94ab998f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; TranslateType &gt; &amp;&#160;</td>
          <td class="paramname"><em>translate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after every MODE command sent from a user The dest variable contains a User* if target_type is TYPE_USER and a Channel* if target_type is TYPE_CHANNEL. The text variable contains the remainder of the mode string after the target, e.g. "+wsi" or "+ooo nick1 nick2 nick3". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the MODEs </td></tr>
    <tr><td class="paramname">dest</td><td>The target of the modes (User* or Channel*) </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of target (TYPE_USER or TYPE_CHANNEL) </td></tr>
    <tr><td class="paramname">text</td><td>The actual modes and their parameters if any </td></tr>
    <tr><td class="paramname">translate</td><td>The translation types of the mode parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaae6d16d1fe5d629dce9deedaa0a1b49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnModuleRehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called on rehash. This method is called when a user initiates a module-specific rehash. This can be used to do expensive operations (such as reloading SSL certificates) that are not executed on a normal rehash for efficiency. A rehash of this type does not reload the core configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user performing the rehash. </td></tr>
    <tr><td class="paramname">parameter</td><td>The parameter given to REHASH </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add927647a8531cced935d19f532fe9de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnNamesListItem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>issuer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>nick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called for every item in a NAMES list, so that modules may reformat portions of it as they see fit. For example NAMESX, channel mode +u and +I, and UHNAMES. If the nick is set to an empty string by any module, then this will cause the nickname not to be displayed at all. </p>

</div>
</div>
<a class="anchor" id="afb6f7ea0790f23d6c15ff3daf40b7f48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnOper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opertype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user opers locally. The <a class="el" href="class_user.html">User</a> will contain the oper mode 'o' as this function is called after any modifications are made to the user's structure by the core. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is opering up </td></tr>
    <tr><td class="paramname">opertype</td><td>The opers type name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2a40bf5ebb638640047a5089e41c333"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnPassCompare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_extensible.html">Extensible</a> *&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hashtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a password check is to be made. Replaces the old OldOperCompare API. The password field (from the config file) is in 'password' and is to be compared against 'input'. This method allows for encryption of passwords (oper, connect:allow, die/restart, etc). You should return a nonzero value to override the normal comparison, or zero to pass it on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The object that's causing the authentication (User* for &lt;oper&gt; &lt;connect:allow&gt; etc, Server* for &lt;link&gt;). </td></tr>
    <tr><td class="paramname">password</td><td>The password from the configuration file (the password="" value). </td></tr>
    <tr><td class="paramname">input</td><td>The password entered by the user or whoever. </td></tr>
    <tr><td class="paramname">hashtype</td><td>The hash value from the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 to do nothing (pass on to next module/default), 1 == password is OK, -1 == password is not OK </dd></dl>

</div>
</div>
<a class="anchor" id="a098c9e5b967414eb73f5f1c3eb4952e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPostCommand </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmdResult&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after any command has been executed. This event occurs for all registered commands, wether they are registered in the core, or another module, but it will not occur for invalid commands (e.g. ones which do not exist within the command table). The result code returned by the command handler is provided. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command being executed </td></tr>
    <tr><td class="paramname">parameters</td><td>An array of array of characters containing the parameters for the command </td></tr>
    <tr><td class="paramname">user</td><td>the user issuing the command </td></tr>
    <tr><td class="paramname">result</td><td>The return code given by the command handler, one of CMD_SUCCESS or CMD_FAILURE </td></tr>
    <tr><td class="paramname">original_line</td><td>The entire original line as passed to the parser from the user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3a7c87d002fe32d4d0f46a7f438fbbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPostConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a user has fully connected and all modules have executed OnUserConnect This event is informational only. You should not change any user information in this event. To do so, use the OnUserConnect method to change the state of local users. This is called for both local and remote users. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is connecting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3be3a9518b0ee13a391ae6daffa5553"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPostJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a user joins a channel Identical to OnUserJoin, but called immediately afterwards, when any linking module has seen the join. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memb</td><td>The channel membership created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0b2ffd9df24552ff78888a536faceba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPostOper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opername</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>opertype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a user opers locally. This is identical to <a class="el" href="class_module.html#afb6f7ea0790f23d6c15ff3daf40b7f48">Module::OnOper()</a>, except it is called after OnOper so that other modules can be gauranteed to already have processed the oper-up, for example m_spanningtree has sent out the OPERTYPE, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is opering up </td></tr>
    <tr><td class="paramname">opername</td><td>The name of the oper that the user is opering up to. Only valid locally. Empty string otherwise. </td></tr>
    <tr><td class="paramname">opertype</td><td>The opers type name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a6faca7798ee9ac8a9330c79bacbcd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPostTopicChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a topic has been changed. To block topic changes you must use OnPreTopicChange instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user changing the topic </td></tr>
    <tr><td class="paramname">chan</td><td>The channels who's topic is being changed </td></tr>
    <tr><td class="paramname">topic</td><td>The actual topic text </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a678967e0e769ecd295a3a272fa488af3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnPreCommand </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>validated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original_line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever any command is about to be executed. This event occurs for all registered commands, wether they are registered in the core, or another module, and for invalid commands. Invalid commands may only be sent to this function when the value of validated is false. By returning 1 from this method you may prevent the command being executed. If you do this, no output is created by the core, and it is down to your module to produce any output neccessary. Note that unless you return 1, you should not destroy any structures (e.g. by using InspIRCd::QuitUser) otherwise when the command's handler function executes after your method returns, it will be passed an invalid pointer to the user object and crash!) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command being executed </td></tr>
    <tr><td class="paramname">parameters</td><td>An array of array of characters containing the parameters for the command </td></tr>
    <tr><td class="paramname">user</td><td>the user issuing the command </td></tr>
    <tr><td class="paramname">validated</td><td>True if the command has passed all checks, e.g. it is recognised, has enough parameters, the user has permission to execute it, etc. You should only change the parameter list and command string if validated == false (e.g. before the command lookup occurs). </td></tr>
    <tr><td class="paramname">original_line</td><td>The entire original line as passed to the parser from the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to block the command, 0 to allow </dd></dl>

</div>
</div>
<a class="anchor" id="af5c3d1cf69b8b43b133ad4bf18e110ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnPreMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before any mode change, to allow a single access check for a full mode change (use OnRawMode to check individual modes)</p>
<p>Returning MOD_RES_ALLOW will skip prefix level checks, but can be overridden by OnRawMode for each individual mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the user making the mode change </td></tr>
    <tr><td class="paramname">dest</td><td>the user destination of the umode change (NULL if a channel mode) </td></tr>
    <tr><td class="paramname">channel</td><td>the channel destination of the mode change </td></tr>
    <tr><td class="paramname">parameters</td><td>raw mode parameters; parameters[0] is the user/channel being changed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a390969a3664c10646dfe13be95ac016d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnPreRehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called on rehash. This method is called prior to a /REHASH or when a SIGHUP is received from the operating system. This is called in all cases &ndash; including when this server will not execute the rehash because it is directed at a remote server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user performing the rehash, if any. If this is server initiated, the value of this variable will be NULL. </td></tr>
    <tr><td class="paramname">parameter</td><td>The (optional) parameter given to REHASH from the user. Empty when server initiated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf0fffc69b3af9695efaec60df2a1876"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnPreTopicChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>topic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before a topic is changed. Return 1 to deny the topic change, 0 to check details on the change, -1 to let it through with no checks As with other 'pre' events, you should only ever block a local event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user changing the topic </td></tr>
    <tr><td class="paramname">chan</td><td>The channels who's topic is being changed </td></tr>
    <tr><td class="paramname">topic</td><td>The actual topic text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to block the topic change, 0 to allow </dd></dl>

</div>
</div>
<a class="anchor" id="a23bbfae81a74a9cb3131c3e7c1f3cfe7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnRawMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a mode character is processed. Return 1 from this function to block the mode character from being processed entirely. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is sending the mode </td></tr>
    <tr><td class="paramname">chan</td><td>The channel the mode is being sent to (or NULL if a usermode) </td></tr>
    <tr><td class="paramname">mode</td><td>The mode character being set </td></tr>
    <tr><td class="paramname">param</td><td>The parameter for the mode or an empty string </td></tr>
    <tr><td class="paramname">adding</td><td>true of the mode is being added, false if it is being removed </td></tr>
    <tr><td class="paramname">pcnt</td><td>The parameter count for the mode (0 or 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ACR_DENY to deny the mode, ACR_DEFAULT to do standard mode checking, and ACR_ALLOW to skip all permission checking. Please note that for remote mode changes, your return value will be ignored! </dd></dl>

</div>
</div>
<a class="anchor" id="a214c9dcd9bbc331697d4ed7ccd173f58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnRehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called on rehash. This method is called after a rehash has completed. You should use it to reload any module configuration from the main configuration file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user that performed the rehash, if it was initiated by a user and that user is still connected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7d0823f952be21553f6846617907a36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnRemoteKill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>operreason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when an oper wants to disconnect a remote user via KILL </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user sending the KILL </td></tr>
    <tr><td class="paramname">dest</td><td>The user being killed </td></tr>
    <tr><td class="paramname">reason</td><td>The kill reason </td></tr>
    <tr><td class="paramname">operreason</td><td>The oper kill reason </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e0478b88aede4d02676433246543eff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_request.html">Request</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a <a class="el" href="class_request.html">Request</a> class is sent to your module by another module. The value of <a class="el" href="class_request.html#aee070353bc753ed93af08b35d02d3662">Request::id</a> should be used to determine the type of request. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>The <a class="el" href="class_request.html">Request</a> class being received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a405c9943fe759d41055f7341c1d916b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnRunTestSuite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add test suite hooks here. These are used for testing functionality of a module via the &ndash;testsuite debugging parameter. </p>

</div>
</div>
<a class="anchor" id="a7d39c9fabab9dea701f4a3ad2cfff37b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnSendSnotice </td>
          <td>(</td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>snomask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a snotice is about to be sent to a snomask. snomask and type may both be modified; the message may not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snomask</td><td>The snomask the message is going to (e.g. 'A') </td></tr>
    <tr><td class="paramname">type</td><td>The textual description the snomask will go to (e.g. 'OPER') </td></tr>
    <tr><td class="paramname">message</td><td>The text message to be sent via snotice </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to block the snotice from being sent entirely, 0 else. </dd></dl>

</div>
</div>
<a class="anchor" id="aced8dd06b3db2733ac012b490a84254e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnSendWhoLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a result from /WHO is about to be returned </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user running the /WHO query </td></tr>
    <tr><td class="paramname">params</td><td>The parameters to the /WHO query </td></tr>
    <tr><td class="paramname">user</td><td>The user that this line of the query is about </td></tr>
    <tr><td class="paramname">line</td><td>The raw line to send; modifiable, if empty no line will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab16f4b39fb1f4353ad2f5d8b652e7425"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnSetAway </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>awaymsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user sets away or returns from being away. The away message is available as a parameter, but should not be modified. At this stage, it has already been copied into the user record. If awaymsg is empty, the user is returning from away. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user setting away </td></tr>
    <tr><td class="paramname">awaymsg</td><td>The away message of the user, or empty if returning from away </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if the away message should be blocked - should ONLY be nonzero for LOCAL users (IS_LOCAL) (no output is returned by core) </dd></dl>

</div>
</div>
<a class="anchor" id="a5a7c6fc1a66af63568b6a69db294a0df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnSetConnectClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_connect_class.html">ConnectClass</a> *&#160;</td>
          <td class="paramname"><em>myclass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user's connect class is being matched </p><dl class="section return"><dt>Returns</dt><dd>MOD_RES_ALLOW to force the class to match, MOD_RES_DENY to forbid it, or MOD_RES_PASSTHRU to allow normal matching (by host/port). </dd></dl>

</div>
</div>
<a class="anchor" id="a3d9edd94c35056b40d076acf56c6afa0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnSetUserIP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a local user's IP is set for the first time, or when a local user's IP changes due to a module like m_cgiirc changing it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user whose IP is being set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fdbb320fa09ddfc3e17249cf0f057ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnStats </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string_list &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called on all /STATS commands This method is triggered for all /STATS use, including stats symbols handled by the core. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>the symbol provided to /STATS </td></tr>
    <tr><td class="paramname">user</td><td>the user issuing the /STATS command </td></tr>
    <tr><td class="paramname">results</td><td>A string_list to append results into. You should put all your results into this string_list, rather than displaying them directly, so that your handler will work when remote STATS queries are received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to block the /STATS from being processed by the core, 0 to allow it </dd></dl>

</div>
</div>
<a class="anchor" id="a86748a9b6b0c7d70327f584aa6e3312d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnStreamSocketAccept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_stream_socket.html">StreamSocket</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> *&#160;</td>
          <td class="paramname"><em>server</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called immediately after any connection is accepted. This is intended for raw socket processing (e.g. modules which wrap the tcp connection within another library) and provides no information relating to a user record as the connection has not been assigned yet. There are no return values from this call as all modules get an opportunity if required to process the connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket in question </td></tr>
    <tr><td class="paramname">client</td><td>The client IP address and port </td></tr>
    <tr><td class="paramname">server</td><td>The server IP address and port </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc646ceff0374f658038bd5eee47ebda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnStreamSocketClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_stream_socket.html">StreamSocket</a> *&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called immediately before any socket is closed. When this event is called, shutdown() has not yet been called on the socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a436071d564fd9240194a7ea43768bda7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnStreamSocketConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_stream_socket.html">StreamSocket</a> *&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called immediately upon connection of an outbound <a class="el" href="class_buffered_socket.html">BufferedSocket</a> which has been hooked by a module. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d4c72cc4fe3c64df0b7724e7e49d76b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Module::OnStreamSocketRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_stream_socket.html">StreamSocket</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>recvq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when the stream socket has data to read </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket that is ready </td></tr>
    <tr><td class="paramname">recvq</td><td>The receive queue that new data should be appended to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if new data has been read, 0 if no new data is ready (but the socket is still connected), -1 if there was an error or close </dd></dl>

</div>
</div>
<a class="anchor" id="aecfbf68998422b227693e26aadcf9dbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Module::OnStreamSocketWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_stream_socket.html">StreamSocket</a> *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>sendq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a hooked stream has data to write, or when the socket engine returns it as writable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket in question </td></tr>
    <tr><td class="paramname">sendq</td><td>Data to send to the socket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the sendq has been completely emptied, 0 if there is still data to send, and -1 if there was an error </dd></dl>

</div>
</div>
<a class="anchor" id="a4f6ddca119f70f61a24e77b7efdeea07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnSyncChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>proto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows modules to synchronize data which relates to channels during a netburst. When this function is called, it will be called from the module which implements the linking protocol. This currently is m_spanningtree.so. A pointer to this module is given in Module* proto, so that you may call its methods such as ProtoSendMode (see below). This function will be called for every user visible on your side of the burst, allowing you to for example set modes, etc.</p>
<p>For a good example of how to use this function, please see src/modules/m_chanprotect.cpp</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>The channel being syncronized </td></tr>
    <tr><td class="paramname">proto</td><td>A pointer to the module handling network protocol </td></tr>
    <tr><td class="paramname">opaque</td><td>An opaque pointer set by the protocol module, should not be modified! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb0d58aeef06736a367072e593116ce0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnSyncUser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>proto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows modules to synchronize data which relates to users during a netburst. When this function is called, it will be called from the module which implements the linking protocol. This currently is m_spanningtree.so. A pointer to this module is given in Module* proto, so that you may call its methods such as ProtoSendMode (see below). This function will be called for every user visible on your side of the burst, allowing you to for example set modes, etc. Do not use this call to synchronize data which you have stored using class <a class="el" href="class_extensible.html">Extensible</a> &ndash; There is a specialist function OnSyncUserMetaData and OnSyncChannelMetaData for this! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user being syncronized </td></tr>
    <tr><td class="paramname">proto</td><td>A pointer to the module handling network protocol </td></tr>
    <tr><td class="paramname">opaque</td><td>An opaque pointer set by the protocol module, should not be modified! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19baf615db55e3363cd3065674fc3b72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>exempt_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called immediately before any NOTICE or PRIVMSG sent from a user, local or remote. The dest variable contains a User* if target_type is TYPE_USER and a Channel* if target_type is TYPE_CHANNEL. The difference between this event and OnUserPreNotice/OnUserPreMessage is that delivery is gauranteed, the message has already been vetted. In the case of the other two methods, a later module may stop your message. This also differs from OnUserMessage which occurs AFTER the message has been sent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message </td></tr>
    <tr><td class="paramname">dest</td><td>The target of the message </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of target (TYPE_USER or TYPE_CHANNEL) </td></tr>
    <tr><td class="paramname">text</td><td>the text being sent by the user </td></tr>
    <tr><td class="paramname">status</td><td>The status being used, e.g. NOTICE #chan has status== '@', 0 to send to everyone. </td></tr>
    <tr><td class="paramname">exempt_list</td><td>A list of users not to send to. For channel messages, this will usually contain just the sender. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab55ed63d022db5f011db3d8c03ef6953"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUnloadModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a module is unloaded. mod will contain a pointer to the module, and string will contain its name, for example m_widgets.so. This function is primary for dependency checking, your module may decide to enable some extra features if it sees that you have for example loaded "m_killwidgets.so" with "m_makewidgets.so". It is highly recommended that modules do <em>NOT</em> bail if they cannot satisfy dependencies, but instead operate under reduced functionality, unless the dependency is absolutely neccessary (e.g. a module that extends the features of another module). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Pointer to the module being unloaded (still valid) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3910edd1a48dfe4db141b04157627a8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user connects. The details of the connecting user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is connecting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a193075c27aee23eb8baf613ed31327b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserDisconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user's socket is closed. The details of the exiting user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user This event is called for all users, registered or not, as a cleanup method for modules which might assign resources to user, such as dns lookups, objects and sockets. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is disconnecting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45ed68d2c341e59dd9acc50672d67aae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user is first connecting, prior to starting <a class="el" href="class_d_n_s.html">DNS</a> lookups, checking initial connect class, or accepting any commands. </p>

</div>
</div>
<a class="anchor" id="ab317fe70e3a528ad41c43f5cb3e252a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserInvite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a user has been successfully invited to a channel. You cannot prevent the invite from occuring using this function, to do that, use OnUserPreInvite instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user who is issuing the INVITE </td></tr>
    <tr><td class="paramname">dest</td><td>The user being invited </td></tr>
    <tr><td class="paramname">channel</td><td>The channel the user is being invited to </td></tr>
    <tr><td class="paramname">timeout</td><td>The time the invite will expire (0 == never) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4e65c3401aff9a6c68e2b2f9f2de5dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>created</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>except_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user joins a channel. The details of the joining user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user, and the details of the channel they have joined is available in the variable <a class="el" href="class_channel.html">Channel</a> *channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memb</td><td>The channel membership being created </td></tr>
    <tr><td class="paramname">sync</td><td>This is set to true if the JOIN is the result of a network sync and the remote user is being introduced to a channel due to the network sync. </td></tr>
    <tr><td class="paramname">created</td><td>This is true if the join created the channel </td></tr>
    <tr><td class="paramname">except_list</td><td>A list of users not to send to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a0c7ca18eadf768e69894f2995b0db7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserKick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>except_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is kicked. If this method is called, the kick is already underway and cannot be prevented, so to prevent a kick, please use <a class="el" href="class_module.html#a54fb5e86ea38f35095af102f40894c1b">Module::OnUserPreKick</a> instead of this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user issuing the kick </td></tr>
    <tr><td class="paramname">memb</td><td>The channel membership of the user who was kicked. </td></tr>
    <tr><td class="paramname">reason</td><td>The kick reason </td></tr>
    <tr><td class="paramname">except_list</td><td>A list of users to not send to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57c261f2aa608ecdad8ae704734505f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUList &amp;&#160;</td>
          <td class="paramname"><em>exempt_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after any PRIVMSG sent from a user. The dest variable contains a User* if target_type is TYPE_USER and a Channel* if target_type is TYPE_CHANNEL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message </td></tr>
    <tr><td class="paramname">dest</td><td>The target of the message </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of target (TYPE_USER or TYPE_CHANNEL) </td></tr>
    <tr><td class="paramname">text</td><td>the text being sent by the user </td></tr>
    <tr><td class="paramname">status</td><td>The status being used, e.g. PRIVMSG #chan has status== '@', 0 to send to everyone. </td></tr>
    <tr><td class="paramname">exempt_list</td><td>A list of users to not send to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a7e309f4ac701329acdc0b5600ee678"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserNotice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUList &amp;&#160;</td>
          <td class="paramname"><em>exempt_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after any NOTICE sent from a user. The dest variable contains a User* if target_type is TYPE_USER and a Channel* if target_type is TYPE_CHANNEL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message </td></tr>
    <tr><td class="paramname">dest</td><td>The target of the message </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of target (TYPE_USER or TYPE_CHANNEL) </td></tr>
    <tr><td class="paramname">text</td><td>the text being sent by the user </td></tr>
    <tr><td class="paramname">status</td><td>The status being used, e.g. NOTICE #chan has status== '@', 0 to send to everyone. </td></tr>
    <tr><td class="paramname">exempt_list</td><td>A list of users to not send to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a100db8d416d1484716999076880f63d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserPart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>partmessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>except_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user parts a channel. The details of the leaving user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user, and the details of the channel they have left is available in the variable <a class="el" href="class_channel.html">Channel</a> *channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memb</td><td>The channel membership being destroyed </td></tr>
    <tr><td class="paramname">partmessage</td><td>The part message, or an empty string (may be modified) </td></tr>
    <tr><td class="paramname">except_list</td><td>A list of users to not send to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad35164fe098f2acdec99d3e242e585e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserPostNick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldnick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after any nickchange, local or remote. This can be used to track users after nickchanges have been applied. Please note that although you can see remote nickchanges through this function, you should NOT make any changes to the <a class="el" href="class_user.html">User</a> if the user is a remote user as this may cause a desnyc. check user-&gt;server before taking any action (including returning nonzero from the method). Because this method is called after the nickchange is taken place, no return values are possible to indicate forbidding of the nick change. Use OnUserPreNick for this. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user changing their nick </td></tr>
    <tr><td class="paramname">oldnick</td><td>The old nickname of the user before the nickchange </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c2b1fed6b47eda0305f04426db05baf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnUserPreInvite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is about to invite another user into a channel, before any processing is done. Returning 1 from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc. This is useful for modules which may want to filter invites to channels. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user who is issuing the INVITE </td></tr>
    <tr><td class="paramname">dest</td><td>The user being invited </td></tr>
    <tr><td class="paramname">channel</td><td>The channel the user is being invited to </td></tr>
    <tr><td class="paramname">timeout</td><td>The time the invite will expire (0 == never) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to deny the invite, 0 to check whether or not the user has permission to invite, -1 to explicitly allow the invite </dd></dl>

</div>
</div>
<a class="anchor" id="aa3bd372d9510aaeb1181e75295924649"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnUserPreJoin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>privs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>keygiven</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is about to join a channel, before any processing is done. Returning a value of 1 from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc. This is useful for modules which may want to mimic +b, +k, +l etc. Returning -1 from this function forces the join to be allowed, bypassing restrictions such as banlists, invite, keys etc.</p>
<p>IMPORTANT NOTE!</p>
<p>If the user joins a NEW channel which does not exist yet, OnUserPreJoin will be called BEFORE the channel record is created. This will cause Channel* chan to be NULL. There is very little you can do in form of processing on the actual channel record at this point, however the channel NAME will still be passed in char* cname, so that you could for example implement a channel blacklist or whitelist, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user joining the channel </td></tr>
    <tr><td class="paramname">chan</td><td>If the channel is a new channel, this will be NULL, otherwise it will be a pointer to the channel being joined </td></tr>
    <tr><td class="paramname">cname</td><td>The channel name being joined. For new channels this is valid where chan is not. </td></tr>
    <tr><td class="paramname">privs</td><td>A string containing the users privilages when joining the channel. For new channels this will contain "o". You may alter this string to alter the user's modes on the channel. </td></tr>
    <tr><td class="paramname">keygiven</td><td>The key given to join the channel, or an empty string if none was provided </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 To prevent the join, 0 to allow it. </dd></dl>

</div>
</div>
<a class="anchor" id="a54fb5e86ea38f35095af102f40894c1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnUserPreKick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_membership.html">Membership</a> *&#160;</td>
          <td class="paramname"><em>memb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is about to be kicked. Returning a value of 1 from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user issuing the kick </td></tr>
    <tr><td class="paramname">memb</td><td>The channel membership of the user who is being kicked. </td></tr>
    <tr><td class="paramname">reason</td><td>The kick reason </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to prevent the kick, 0 to continue normally, -1 to explicitly allow the kick regardless of normal operation </dd></dl>

</div>
</div>
<a class="anchor" id="a6982393c29ffcd698dc42e345fbd9d84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnUserPreMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>exempt_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is about to PRIVMSG A user or a channel, before any processing is done. Returning any nonzero value from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc. This is useful for modules which may want to filter or redirect messages. target_type can be one of TYPE_USER or TYPE_CHANNEL. If the target_type value is a user, you must cast dest to a User* otherwise you must cast it to a Channel*, this is the details of where the message is destined to be sent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message </td></tr>
    <tr><td class="paramname">dest</td><td>The target of the message (Channel* or User*) </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of target (TYPE_USER or TYPE_CHANNEL) </td></tr>
    <tr><td class="paramname">text</td><td>Changeable text being sent by the user </td></tr>
    <tr><td class="paramname">status</td><td>The status being used, e.g. PRIVMSG #chan has status== '@', 0 to send to everyone. </td></tr>
    <tr><td class="paramname">exempt_list</td><td>A list of users not to send to. For channel messages, this will usually contain just the sender. It will be ignored for private messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to deny the message, 0 to allow it </dd></dl>

</div>
</div>
<a class="anchor" id="a14c0588d2b9536f3ac984745cfe9fe0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnUserPreNick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newnick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before any nickchange, local or remote. This can be used to implement Q-lines etc. Please note that although you can see remote nickchanges through this function, you should NOT make any changes to the <a class="el" href="class_user.html">User</a> if the user is a remote user as this may cause a desnyc. check user-&gt;server before taking any action (including returning nonzero from the method). If your method returns nonzero, the nickchange is silently forbidden, and it is down to your module to generate some meaninful output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The username changing their nick </td></tr>
    <tr><td class="paramname">newnick</td><td>Their new nickname </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to deny the change, 0 to allow </dd></dl>

</div>
</div>
<a class="anchor" id="a1daccd21f78e44a5855d916d35873628"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnUserPreNotice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUList &amp;&#160;</td>
          <td class="paramname"><em>exempt_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is about to NOTICE A user or a channel, before any processing is done. Returning any nonzero value from this function stops the process immediately, causing no output to be sent to the user by the core. If you do this you must produce your own numerics, notices etc. This is useful for modules which may want to filter or redirect messages. target_type can be one of TYPE_USER or TYPE_CHANNEL. If the target_type value is a user, you must cast dest to a User* otherwise you must cast it to a Channel*, this is the details of where the message is destined to be sent. You may alter the message text as you wish before relinquishing control to the next module in the chain, and if no other modules block the text this altered form of the text will be sent out to the user and possibly to other servers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the message </td></tr>
    <tr><td class="paramname">dest</td><td>The target of the message (Channel* or User*) </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of target (TYPE_USER or TYPE_CHANNEL) </td></tr>
    <tr><td class="paramname">text</td><td>Changeable text being sent by the user </td></tr>
    <tr><td class="paramname">status</td><td>The status being used, e.g. PRIVMSG #chan has status== '@', 0 to send to everyone. </td></tr>
    <tr><td class="paramname">exempt_list</td><td>A list of users not to send to. For channel notices, this will usually contain just the sender. It will be ignored for private notices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to deny the NOTICE, 0 to allow it </dd></dl>

</div>
</div>
<a class="anchor" id="a467945d27be3edec8fbd0de9a37a0c31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnUserQuit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oper_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a user quits. The details of the exiting user are available to you in the parameter <a class="el" href="class_user.html">User</a> *user This event is only called when the user is fully registered when they quit. To catch raw disconnections, use the OnUserDisconnect method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user who is quitting </td></tr>
    <tr><td class="paramname">message</td><td>The user's quit message (as seen by non-opers) </td></tr>
    <tr><td class="paramname">oper_message</td><td>The user's quit message (as seen by opers) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeee48e5f4d4efbb826f462c1e5f4d0ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnUserRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_local_user.html">LocalUser</a> *&#160;</td>
          <td class="paramname"><em>user</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a user is about to register their connection (e.g. before the user is sent the MOTD etc). Modules can use this method if they are performing a function which must be done before the actual connection is completed (e.g. ident lookups, dnsbl lookups, etc). Note that you should NOT delete the user record here by causing a disconnection! Use OnUserConnect for that instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user registering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to indicate user quit, 0 to continue </dd></dl>

</div>
</div>
<a class="anchor" id="aa76e89f05626000f80f205db32671d56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnWallops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after every WALLOPS command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user sending the WALLOPS </td></tr>
    <tr><td class="paramname">text</td><td>The content of the WALLOPS message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a450dc0c85646c5286f1c84f2c2d1ed14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::OnWhois </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a /WHOIS is performed on a local user. The source parameter contains the details of the user who issued the WHOIS command, and the dest parameter contains the information of the user they are whoising. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user issuing the WHOIS command </td></tr>
    <tr><td class="paramname">dest</td><td>The user who is being WHOISed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b4bdaeb323660a3b9120195f8a6cbcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_mod_result.html">ModResult</a> Module::OnWhoisLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numeric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a line of WHOIS output is sent to a user. You may change the numeric and the text of the output by changing the values numeric and text, but you cannot change the user the numeric is sent to. You may however change the user's <a class="el" href="class_user.html">User</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user the numeric is being sent to </td></tr>
    <tr><td class="paramname">dest</td><td>The user being WHOISed </td></tr>
    <tr><td class="paramname">numeric</td><td>The numeric of the line being sent </td></tr>
    <tr><td class="paramname">text</td><td>The text of the numeric, including any parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero to drop the line completely so that the user does not receive it, or zero to allow the line to be sent. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bb9dac5417ed8538e5174ebafd25e12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::ProtoSendMetaData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_extensible.html">Extensible</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implemented by modules which provide the ability to link servers. These modules will implement this method, which allows metadata (extra data added to user and channel records using class <a class="el" href="class_extensible.html">Extensible</a>, Extensible::Extend, etc) to be sent to other servers on a netburst and decoded at the other end by the same module on a different server.</p>
<p>More documentation to follow soon. Please see src/modules/m_swhois.cpp for example of how to use this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opaque</td><td>An opaque pointer set by the protocol module, should not be modified! </td></tr>
    <tr><td class="paramname">target</td><td>The Channel* or User* that metadata should be sent for </td></tr>
    <tr><td class="paramname">extname</td><td>The extension name to send metadata for </td></tr>
    <tr><td class="paramname">extdata</td><td>Encoded data for this extension name, which will be encoded at the oppsite end by an identical module using OnDecodeMetaData </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0861ead2131a6edbb77bf4be1d2104ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Module::ProtoSendMode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TargetTypeFlags&#160;</td>
          <td class="paramname"><em>target_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>modeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; TranslateType &gt; &amp;&#160;</td>
          <td class="paramname"><em>translate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implemented by modules which provide the ability to link servers. These modules will implement this method, which allows transparent sending of servermodes down the network link as a broadcast, without a module calling it having to know the format of the MODE command before the actual mode string.</p>
<p>More documentation to follow soon. Please see src/modules/m_chanprotect.cpp for examples of how to use this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opaque</td><td>An opaque pointer set by the protocol module, should not be modified! </td></tr>
    <tr><td class="paramname">target_type</td><td>The type of item to decode data for, TYPE_USER or TYPE_CHANNEL </td></tr>
    <tr><td class="paramname">target</td><td>The Channel* or User* that modes should be sent for </td></tr>
    <tr><td class="paramname">modeline</td><td>The modes and parameters to be sent </td></tr>
    <tr><td class="paramname">translate</td><td>The translation types of the mode parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aab94177da81fe7a68f37e48a554e272f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Module::dying</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If true, this module will be unloaded soon, further unload attempts will fail Value is used by the <a class="el" href="class_module_manager.html">ModuleManager</a> internally, you should not modify it </p>

</div>
</div>
<a class="anchor" id="a5bbdc3c59248520549e5904bb402e2cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_l_l_manager.html">DLLManager</a>* Module::ModuleDLLManager</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference to the dlopen() value </p>

</div>
</div>
<a class="anchor" id="a4b9d41041b7b56a786064020e9c50c75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Module::ModuleSourceFile</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>File that this module was loaded from </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="modules_8h_source.html">modules.h</a></li>
<li>src/modules.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
