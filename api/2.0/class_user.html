<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>InspIRCd: User Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">InspIRCd
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_user-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">User Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="users_8h_source.html">users.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for User:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_user.png" usemap="#User_map" alt=""/>
  <map id="User_map" name="User_map">
<area href="class_extensible.html" alt="Extensible" shape="rect" coords="89,56,168,80"/>
<area href="classclassbase.html" alt="classbase" shape="rect" coords="89,0,168,24"/>
<area href="class_fake_user.html" alt="FakeUser" shape="rect" coords="0,168,79,192"/>
<area href="class_local_user.html" alt="LocalUser" shape="rect" coords="89,168,168,192"/>
<area href="class_remote_user.html" alt="RemoteUser" shape="rect" coords="178,168,257,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab0806f9cdebcadc1718a20f849484f59"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#ab0806f9cdebcadc1718a20f849484f59">GetIPString</a> ()</td></tr>
<tr class="separator:ab0806f9cdebcadc1718a20f849484f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a48058fd59033a8e606492339d5d41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structirc_1_1sockets_1_1cidr__mask.html">irc::sockets::cidr_mask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a54a48058fd59033a8e606492339d5d41">GetCIDRMask</a> ()</td></tr>
<tr class="separator:a54a48058fd59033a8e606492339d5d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f261163f93f5d70232d530c56a6cb2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#af1f261163f93f5d70232d530c56a6cb2">SetClientIP</a> (const char *sip, bool recheck_eline=true)</td></tr>
<tr class="separator:af1f261163f93f5d70232d530c56a6cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715b0bc91292af35549cff8d3440024a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a715b0bc91292af35549cff8d3440024a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetClientIP</b> (const <a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> &amp;sa, bool recheck_eline=true)</td></tr>
<tr class="separator:a715b0bc91292af35549cff8d3440024a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbd4d37951bfbed06010918882408a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a9fbd4d37951bfbed06010918882408a6">User</a> (const std::string &amp;uid, const std::string &amp;srv, int objtype)</td></tr>
<tr class="separator:a9fbd4d37951bfbed06010918882408a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818a94db6cfdd02f7754bd893a0843e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a818a94db6cfdd02f7754bd893a0843e2">CheckLines</a> (bool doZline=false)</td></tr>
<tr class="separator:a818a94db6cfdd02f7754bd893a0843e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242725aae6836377706ed4e202c5893e"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a242725aae6836377706ed4e202c5893e">GetFullHost</a> ()</td></tr>
<tr class="separator:a242725aae6836377706ed4e202c5893e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e57732a6d19e587c89e2b733796858c"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a1e57732a6d19e587c89e2b733796858c">GetFullRealHost</a> ()</td></tr>
<tr class="separator:a1e57732a6d19e587c89e2b733796858c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d27df0379f0f7fc83de02b73673b1aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a5d27df0379f0f7fc83de02b73673b1aa">InvalidateCache</a> ()</td></tr>
<tr class="separator:a5d27df0379f0f7fc83de02b73673b1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c54a5da739aa6da5c68bb7c9bb269ed"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a5c54a5da739aa6da5c68bb7c9bb269ed">FormatNoticeMasks</a> ()</td></tr>
<tr class="separator:a5c54a5da739aa6da5c68bb7c9bb269ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8a245fa3f3df4151e6601fcbf4da73"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a3d8a245fa3f3df4151e6601fcbf4da73">ProcessNoticeMasks</a> (const char *sm)</td></tr>
<tr class="separator:a3d8a245fa3f3df4151e6601fcbf4da73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431867efdb64fc12b42fcfe405c8df17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a431867efdb64fc12b42fcfe405c8df17">IsNoticeMaskSet</a> (unsigned char sm)</td></tr>
<tr class="separator:a431867efdb64fc12b42fcfe405c8df17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1bbc0d3005ba309d1a0572e4a88088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a7c1bbc0d3005ba309d1a0572e4a88088">SetNoticeMask</a> (unsigned char sm, bool value)</td></tr>
<tr class="separator:a7c1bbc0d3005ba309d1a0572e4a88088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4211c1af70cbbac3fef41988fe68f4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#abe4211c1af70cbbac3fef41988fe68f4">FormatModes</a> (bool showparameters=false)</td></tr>
<tr class="separator:abe4211c1af70cbbac3fef41988fe68f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f8f16c80d3361f4df27faee248311f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a45f8f16c80d3361f4df27faee248311f">IsModeSet</a> (unsigned char m)</td></tr>
<tr class="separator:a45f8f16c80d3361f4df27faee248311f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbebc71012c9e761b870f5dd9851e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a8dbebc71012c9e761b870f5dd9851e69">SetMode</a> (unsigned char m, bool value)</td></tr>
<tr class="separator:a8dbebc71012c9e761b870f5dd9851e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6ae552be7ab53c3cbf83b63e4169c4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#ace6ae552be7ab53c3cbf83b63e4169c4">HasPermission</a> (const std::string &amp;command)</td></tr>
<tr class="separator:ace6ae552be7ab53c3cbf83b63e4169c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fe27b1200383f282624cc8e9b2fa2b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#ad0fe27b1200383f282624cc8e9b2fa2b">HasPrivPermission</a> (const std::string &amp;privstr, bool noisy=false)</td></tr>
<tr class="separator:ad0fe27b1200383f282624cc8e9b2fa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7c295ff9e151bc52a8a5e9afc860f7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a7f7c295ff9e151bc52a8a5e9afc860f7">HasModePermission</a> (unsigned char mode, ModeType type)</td></tr>
<tr class="separator:a7f7c295ff9e151bc52a8a5e9afc860f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513647ef7789fdabf93ea71e9db0d685"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a513647ef7789fdabf93ea71e9db0d685">MakeWildHost</a> ()</td></tr>
<tr class="separator:a513647ef7789fdabf93ea71e9db0d685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1cc6d4dfc7d4e13ebb1071ad088196"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#adc1cc6d4dfc7d4e13ebb1071ad088196">MakeHost</a> ()</td></tr>
<tr class="separator:adc1cc6d4dfc7d4e13ebb1071ad088196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720f53db860db2bfdbc969d1ebcaa919"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a720f53db860db2bfdbc969d1ebcaa919">MakeHostIP</a> ()</td></tr>
<tr class="separator:a720f53db860db2bfdbc969d1ebcaa919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c24399783993b82730fe0e7c2a86d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a85c24399783993b82730fe0e7c2a86d0">AddToWhoWas</a> ()</td></tr>
<tr class="separator:a85c24399783993b82730fe0e7c2a86d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b6ec0dae8b4ee90c0e13c2143622cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#af9b6ec0dae8b4ee90c0e13c2143622cc">Oper</a> (<a class="el" href="class_oper_info.html">OperInfo</a> *info)</td></tr>
<tr class="separator:af9b6ec0dae8b4ee90c0e13c2143622cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f20f125adc5925a8f07df4e1617693"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#ae5f20f125adc5925a8f07df4e1617693">ForceNickChange</a> (const char *newnick)</td></tr>
<tr class="separator:ae5f20f125adc5925a8f07df4e1617693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326d5c537946b4f6c28c659675d1ed43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a326d5c537946b4f6c28c659675d1ed43">UnOper</a> ()</td></tr>
<tr class="separator:a326d5c537946b4f6c28c659675d1ed43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23112c612275acb529af30c2ff60515"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#ac23112c612275acb529af30c2ff60515">Write</a> (const std::string &amp;text)</td></tr>
<tr class="separator:ac23112c612275acb529af30c2ff60515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508ed8ff1be90f5b9e7437966dcf6f26"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a508ed8ff1be90f5b9e7437966dcf6f26">Write</a> (const char *text,...) CUSTOM_PRINTF(2</td></tr>
<tr class="separator:a508ed8ff1be90f5b9e7437966dcf6f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601defc9871b1c57a9c61a26b22a97f8"><td class="memItemLeft" align="right" valign="top">virtual void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a601defc9871b1c57a9c61a26b22a97f8">WriteServ</a> (const std::string &amp;text)</td></tr>
<tr class="separator:a601defc9871b1c57a9c61a26b22a97f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a38a6346a80dc6c0e70689462c80ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a30a38a6346a80dc6c0e70689462c80ad">WriteServ</a> (const char *text,...) CUSTOM_PRINTF(2</td></tr>
<tr class="separator:a30a38a6346a80dc6c0e70689462c80ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94681fe501e9e6301463e836455f4f30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94681fe501e9e6301463e836455f4f30"></a>
void void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteNumeric</b> (unsigned int numeric, const char *text,...) CUSTOM_PRINTF(3</td></tr>
<tr class="separator:a94681fe501e9e6301463e836455f4f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a01ea004823a54ec1c68fe5aa879af8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a01ea004823a54ec1c68fe5aa879af8"></a>
void void void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteNumeric</b> (unsigned int numeric, const std::string &amp;text)</td></tr>
<tr class="separator:a8a01ea004823a54ec1c68fe5aa879af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dbd8971acb541df15a28ccf50495f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a51dbd8971acb541df15a28ccf50495f8">WriteFrom</a> (<a class="el" href="class_user.html">User</a> *user, const std::string &amp;text)</td></tr>
<tr class="separator:a51dbd8971acb541df15a28ccf50495f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b5476e24724e094e55009da9ae79dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#af2b5476e24724e094e55009da9ae79dd">WriteFrom</a> (<a class="el" href="class_user.html">User</a> *user, const char *text,...) CUSTOM_PRINTF(3</td></tr>
<tr class="separator:af2b5476e24724e094e55009da9ae79dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab99c4d21eea090aa8d2e6ec789a3ea4"><td class="memItemLeft" align="right" valign="top">void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#aab99c4d21eea090aa8d2e6ec789a3ea4">WriteTo</a> (<a class="el" href="class_user.html">User</a> *dest, const std::string &amp;data)</td></tr>
<tr class="separator:aab99c4d21eea090aa8d2e6ec789a3ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ebb40ba2e851126126013d73831968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a78ebb40ba2e851126126013d73831968">WriteTo</a> (<a class="el" href="class_user.html">User</a> *dest, const char *data,...) CUSTOM_PRINTF(3</td></tr>
<tr class="separator:a78ebb40ba2e851126126013d73831968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b67ff8a39cf18ea837a56c3339f780a"><td class="memItemLeft" align="right" valign="top">void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a6b67ff8a39cf18ea837a56c3339f780a">WriteCommonRaw</a> (const std::string &amp;line, bool include_self=true)</td></tr>
<tr class="separator:a6b67ff8a39cf18ea837a56c3339f780a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fde66472ef2f5c79ccddc2f0c0e0c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a61fde66472ef2f5c79ccddc2f0c0e0c1">WriteCommon</a> (const char *text,...) CUSTOM_PRINTF(2</td></tr>
<tr class="separator:a61fde66472ef2f5c79ccddc2f0c0e0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aef1c4409bcf990abfdb19777d07369"><td class="memItemLeft" align="right" valign="top">void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a9aef1c4409bcf990abfdb19777d07369">WriteCommonExcept</a> (const char *text,...) CUSTOM_PRINTF(2</td></tr>
<tr class="separator:a9aef1c4409bcf990abfdb19777d07369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404c1c2ad7a87557661b8d9ec4271c9d"><td class="memItemLeft" align="right" valign="top">void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a404c1c2ad7a87557661b8d9ec4271c9d">WriteCommonQuit</a> (const std::string &amp;normal_text, const std::string &amp;oper_text)</td></tr>
<tr class="separator:a404c1c2ad7a87557661b8d9ec4271c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ba1522c6c1f87e20d6205fdb3f66a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a09ba1522c6c1f87e20d6205fdb3f66a1">SendText</a> (const std::string &amp;LinePrefix, std::stringstream &amp;TextStream)</td></tr>
<tr class="separator:a09ba1522c6c1f87e20d6205fdb3f66a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089b36510ac944ed595089373fa7ea16"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a089b36510ac944ed595089373fa7ea16">SendText</a> (const std::string &amp;line)=0</td></tr>
<tr class="separator:a089b36510ac944ed595089373fa7ea16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc8bb0e3cd530e580184e724ab337fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#aecc8bb0e3cd530e580184e724ab337fb">SendText</a> (const char *text,...) CUSTOM_PRINTF(2</td></tr>
<tr class="separator:aecc8bb0e3cd530e580184e724ab337fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626bc5712170aa6ebad4c35153bb951e"><td class="memItemLeft" align="right" valign="top">void bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a626bc5712170aa6ebad4c35153bb951e">SharesChannelWith</a> (<a class="el" href="class_user.html">User</a> *other)</td></tr>
<tr class="separator:a626bc5712170aa6ebad4c35153bb951e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a44281f2f762cbc5ff0ddecfd1d7140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a6a44281f2f762cbc5ff0ddecfd1d7140">DoHostCycle</a> (const std::string &amp;quitline)</td></tr>
<tr class="separator:a6a44281f2f762cbc5ff0ddecfd1d7140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8874c26827c1f3c9b5dec7d4a1483ae6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a8874c26827c1f3c9b5dec7d4a1483ae6">ChangeDisplayedHost</a> (const char *<a class="el" href="class_user.html#a7773fec016477ec1eba2f572b34eea76">host</a>)</td></tr>
<tr class="separator:a8874c26827c1f3c9b5dec7d4a1483ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9713d0ebeb5942641deafde74076023"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#ab9713d0ebeb5942641deafde74076023">ChangeIdent</a> (const char *newident)</td></tr>
<tr class="separator:ab9713d0ebeb5942641deafde74076023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e74feb56f8bc7c6d01e8dc799068cf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a1e74feb56f8bc7c6d01e8dc799068cf9">ChangeName</a> (const char *gecos)</td></tr>
<tr class="separator:a1e74feb56f8bc7c6d01e8dc799068cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859b608c0d234a5c407d2609ecbb9bbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a859b608c0d234a5c407d2609ecbb9bbf">ChangeNick</a> (const std::string &amp;newnick, bool force=false)</td></tr>
<tr class="separator:a859b608c0d234a5c407d2609ecbb9bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82af8e8e4af2129de781ccebc5abe21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#ad82af8e8e4af2129de781ccebc5abe21">SendAll</a> (const char *command, const char *text,...) CUSTOM_PRINTF(3</td></tr>
<tr class="separator:ad82af8e8e4af2129de781ccebc5abe21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314dc765ce3fa346086e6164f3ed8831"><td class="memItemLeft" align="right" valign="top">void std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a314dc765ce3fa346086e6164f3ed8831">ChannelList</a> (<a class="el" href="class_user.html">User</a> *source, bool spy)</td></tr>
<tr class="separator:a314dc765ce3fa346086e6164f3ed8831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6876d094321ba00928b88e507df24cf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a6876d094321ba00928b88e507df24cf8">SplitChanList</a> (<a class="el" href="class_user.html">User</a> *dest, const std::string &amp;cl)</td></tr>
<tr class="separator:a6876d094321ba00928b88e507df24cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03321870943c66415b14404e31128090"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a03321870943c66415b14404e31128090">PurgeEmptyChannels</a> ()</td></tr>
<tr class="separator:a03321870943c66415b14404e31128090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a48da905cc1f023436a445d07ec878"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_connect_class.html">ConnectClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a87a48da905cc1f023436a445d07ec878">GetClass</a> ()</td></tr>
<tr class="separator:a87a48da905cc1f023436a445d07ec878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00b72ad64eb4149f7b21b9f5468c2b2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#ac00b72ad64eb4149f7b21b9f5468c2b2">~User</a> ()</td></tr>
<tr class="separator:ac00b72ad64eb4149f7b21b9f5468c2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d072c238ae1b48f64b2e885674dd72c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_cull_result.html">CullResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a8d072c238ae1b48f64b2e885674dd72c">cull</a> ()</td></tr>
<tr class="separator:a8d072c238ae1b48f64b2e885674dd72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_extensible"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_extensible')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_extensible.html">Extensible</a></td></tr>
<tr class="memitem:ac97ab7b7f39662971a6bc25ae689b705 inherit pub_methods_class_extensible"><td class="memItemLeft" align="right" valign="top">const ExtensibleStore &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_extensible.html#ac97ab7b7f39662971a6bc25ae689b705">GetExtList</a> () const </td></tr>
<tr class="separator:ac97ab7b7f39662971a6bc25ae689b705 inherit pub_methods_class_extensible"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a48c817f6bc3641ab254cafb810321 inherit pub_methods_class_extensible"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2a48c817f6bc3641ab254cafb810321"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>doUnhookExtensions</b> (const std::vector&lt; <a class="el" href="classreference.html">reference</a>&lt; <a class="el" href="class_extension_item.html">ExtensionItem</a> &gt; &gt; &amp;toRemove)</td></tr>
<tr class="separator:af2a48c817f6bc3641ab254cafb810321 inherit pub_methods_class_extensible"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7773fec016477ec1eba2f572b34eea76"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a7773fec016477ec1eba2f572b34eea76">host</a></td></tr>
<tr class="separator:a7773fec016477ec1eba2f572b34eea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e62e3d0a124b4418891e11d76faad7e"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a6e62e3d0a124b4418891e11d76faad7e">age</a></td></tr>
<tr class="separator:a6e62e3d0a124b4418891e11d76faad7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d50e3ac7bdcb5fb96d501d91782eb87"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a1d50e3ac7bdcb5fb96d501d91782eb87">signon</a></td></tr>
<tr class="separator:a1d50e3ac7bdcb5fb96d501d91782eb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249c29ce8508133303dfbe42ed2bf50f"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a249c29ce8508133303dfbe42ed2bf50f">idle_lastmsg</a></td></tr>
<tr class="separator:a249c29ce8508133303dfbe42ed2bf50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118a42a76b20e6cb6de541d9e08041e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a118a42a76b20e6cb6de541d9e08041e9">client_sa</a></td></tr>
<tr class="separator:a118a42a76b20e6cb6de541d9e08041e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6097de89cf5d8fd945c6782cfa7e89fe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a6097de89cf5d8fd945c6782cfa7e89fe">nick</a></td></tr>
<tr class="separator:a6097de89cf5d8fd945c6782cfa7e89fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee4e34fd334d4b5f99fc1fa34b0155a"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a9ee4e34fd334d4b5f99fc1fa34b0155a">uuid</a></td></tr>
<tr class="separator:a9ee4e34fd334d4b5f99fc1fa34b0155a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75afe5805a15221777aaf204d99f17c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a75afe5805a15221777aaf204d99f17c0">ident</a></td></tr>
<tr class="separator:a75afe5805a15221777aaf204d99f17c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e572bdf54a71ea5b12365c4228c6731"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a8e572bdf54a71ea5b12365c4228c6731">dhost</a></td></tr>
<tr class="separator:a8e572bdf54a71ea5b12365c4228c6731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37f981a564b92cb131a4e62e2bd53df"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#aa37f981a564b92cb131a4e62e2bd53df">fullname</a></td></tr>
<tr class="separator:aa37f981a564b92cb131a4e62e2bd53df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1e528b004ddf33833323d4f4473cb6"><td class="memItemLeft" align="right" valign="top">std::bitset&lt; 64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#afb1e528b004ddf33833323d4f4473cb6">modes</a></td></tr>
<tr class="separator:afb1e528b004ddf33833323d4f4473cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98128434f41c8ca644ad0a2429565ef7"><td class="memItemLeft" align="right" valign="top">std::bitset&lt; 64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a98128434f41c8ca644ad0a2429565ef7">snomasks</a></td></tr>
<tr class="separator:a98128434f41c8ca644ad0a2429565ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8babc78ccfb2f6aab5b4d4ecd274c3"><td class="memItemLeft" align="right" valign="top">UserChanList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a0f8babc78ccfb2f6aab5b4d4ecd274c3">chans</a></td></tr>
<tr class="separator:a0f8babc78ccfb2f6aab5b4d4ecd274c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07fe0b29d3b04bf886fb048e4796cbe"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#ab07fe0b29d3b04bf886fb048e4796cbe">server</a></td></tr>
<tr class="separator:ab07fe0b29d3b04bf886fb048e4796cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4f7df5529c3547133907148fbb2918"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a9f4f7df5529c3547133907148fbb2918">awaymsg</a></td></tr>
<tr class="separator:a9f4f7df5529c3547133907148fbb2918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0241e8f5196138096077725a628a476"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#aa0241e8f5196138096077725a628a476">awaytime</a></td></tr>
<tr class="separator:aa0241e8f5196138096077725a628a476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968f02b552b0aac771aef8adac4f823e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreference.html">reference</a>&lt; <a class="el" href="class_oper_info.html">OperInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a968f02b552b0aac771aef8adac4f823e">oper</a></td></tr>
<tr class="separator:a968f02b552b0aac771aef8adac4f823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fabba0257a3d6363d6f0159bba856c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a62fabba0257a3d6363d6f0159bba856c">registered</a>:3</td></tr>
<tr class="separator:a62fabba0257a3d6363d6f0159bba856c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41b92b5c787bccfa3ff625de7522a07"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#ae41b92b5c787bccfa3ff625de7522a07">dns_done</a>:1</td></tr>
<tr class="separator:ae41b92b5c787bccfa3ff625de7522a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace73638d21fef8d2785b3999a8abb149"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#ace73638d21fef8d2785b3999a8abb149">quietquit</a>:1</td></tr>
<tr class="separator:ace73638d21fef8d2785b3999a8abb149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f4fab44458bfa3e944a69c762c4273"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a60f4fab44458bfa3e944a69c762c4273">quitting</a>:1</td></tr>
<tr class="separator:a60f4fab44458bfa3e944a69c762c4273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65949293e21924a52e5ff14f664129e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#ac65949293e21924a52e5ff14f664129e">quitting_sendq</a>:1</td></tr>
<tr class="separator:ac65949293e21924a52e5ff14f664129e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c67c6d6e5d901d0b994e32bdb8ca7a5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a3c67c6d6e5d901d0b994e32bdb8ca7a5">exempt</a>:1</td></tr>
<tr class="separator:a3c67c6d6e5d901d0b994e32bdb8ca7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366e12fdc514b4ddf04441116cc1bbb6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a366e12fdc514b4ddf04441116cc1bbb6">lastping</a>:1</td></tr>
<tr class="separator:a366e12fdc514b4ddf04441116cc1bbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982fa3195231117b83dde5b90ffd4685"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_user.html#a982fa3195231117b83dde5b90ffd4685">usertype</a>:2</td></tr>
<tr class="separator:a982fa3195231117b83dde5b90ffd4685"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_extensible"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_extensible')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_extensible.html">Extensible</a></td></tr>
<tr class="memitem:a28f9821186eb20d25be1c18a68e0ece8 inherit pub_types_class_extensible"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28f9821186eb20d25be1c18a68e0ece8"></a>
typedef std::map&lt; <a class="el" href="classreference.html">reference</a><br class="typebreak" />
&lt; <a class="el" href="class_extension_item.html">ExtensionItem</a> &gt;, void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ExtensibleStore</b></td></tr>
<tr class="separator:a28f9821186eb20d25be1c18a68e0ece8 inherit pub_types_class_extensible"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Holds all information about a user This class stores all information about a user connected to the irc server. Everything about a connection is stored here primarily, from the user's socket ID (file descriptor) through to the user's nickname and hostname. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9fbd4d37951bfbed06010918882408a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">User::User </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>srv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_core_exception.html">CoreException</a></td><td>if the UID allocated to the user already exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac00b72ad64eb4149f7b21b9f5468c2b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">User::~User </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a85c24399783993b82730fe0e7c2a86d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::AddToWhoWas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the user to WHOWAS system </p>

</div>
</div>
<a class="anchor" id="a8874c26827c1f3c9b5dec7d4a1483ae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool User::ChangeDisplayedHost </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the displayed host of a user. ALWAYS use this function, rather than writing <a class="el" href="class_user.html#a8e572bdf54a71ea5b12365c4228c6731">User::dhost</a> directly, as this triggers module events allowing the change to be syncronized to remote servers. This will also emulate a QUIT and rejoin (where configured) before setting their host field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The new hostname to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the change succeeded, false if it didn't </dd></dl>

</div>
</div>
<a class="anchor" id="ab9713d0ebeb5942641deafde74076023"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool User::ChangeIdent </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newident</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the ident (username) of a user. ALWAYS use this function, rather than writing <a class="el" href="class_user.html#a75afe5805a15221777aaf204d99f17c0">User::ident</a> directly, as this correctly causes the user to seem to quit (where configured) before setting their ident field. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newident</td><td>The new ident to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the change succeeded, false if it didn't </dd></dl>

</div>
</div>
<a class="anchor" id="a1e74feb56f8bc7c6d01e8dc799068cf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool User::ChangeName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>gecos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change a users realname field. ALWAYS use this function, rather than writing <a class="el" href="class_user.html#aa37f981a564b92cb131a4e62e2bd53df">User::fullname</a> directly, as this triggers module events allowing the change to be syncronized to remote servers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gecos</td><td>The user's new realname </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the change succeeded, false if otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a859b608c0d234a5c407d2609ecbb9bbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool User::ChangeNick </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newnick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change a user's nick </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newnick</td><td>The new nick </td></tr>
    <tr><td class="paramname">force</td><td>True if the change is being forced (should not be blocked by modes like +N) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the change succeeded </dd></dl>

</div>
</div>
<a class="anchor" id="a314dc765ce3fa346086e6164f3ed8831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string User::ChannelList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>spy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compile a channel list for this user. Used internally by WHOIS </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The user to prepare the channel list for </td></tr>
    <tr><td class="paramname">spy</td><td>Whether to return the spy channel list rather than the normal one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This user's channel list </dd></dl>

</div>
</div>
<a class="anchor" id="a818a94db6cfdd02f7754bd893a0843e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool User::CheckLines </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doZline</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the user matches a G or K line, and disconnect them if they do. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doZline</td><td>True if ZLines should be checked (if IP has changed since initial connect) Returns true if the user matched a ban, false else. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d072c238ae1b48f64b2e885674dd72c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cull_result.html">CullResult</a> User::cull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called just prior to destruction via cull list. </p>

<p>Reimplemented from <a class="el" href="class_extensible.html#a11e8ad72ea9557b4e88c87121858a155">Extensible</a>.</p>

<p>Reimplemented in <a class="el" href="class_fake_user.html#aeba21c721ff0663d033a898f651a905f">FakeUser</a>, and <a class="el" href="class_local_user.html#aadd99034d2d12185b80f4c7111744bfa">LocalUser</a>.</p>

</div>
</div>
<a class="anchor" id="a6a44281f2f762cbc5ff0ddecfd1d7140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::DoHostCycle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>quitline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send fake quit/join messages for host or ident cycle. Run this after the item in question has changed. You should not need to use this function, call ChangeDisplayedHost instead</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quitline</td><td>The entire QUIT line, including the source using the old value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5f20f125adc5925a8f07df4e1617693"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool User::ForceNickChange </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newnick</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Force a nickname change. If the nickname change fails (for example, because the nick in question already exists) this function will return false, and you must then either output an error message, or quit the user for nickname collision. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newnick</td><td>The nickname to change to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the nickchange was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="abe4211c1af70cbbac3fef41988fe68f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * User::FormatModes </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showparameters</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a displayable mode string for this users umodes </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">showparameters</td><td>The mode string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c54a5da739aa6da5c68bb7c9bb269ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * User::FormatNoticeMasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a displayable mode string for this users snomasks </p><dl class="section return"><dt>Returns</dt><dd>The notice mask character sequence </dd></dl>

</div>
</div>
<a class="anchor" id="a54a48058fd59033a8e606492339d5d41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structirc_1_1sockets_1_1cidr__mask.html">irc::sockets::cidr_mask</a> User::GetCIDRMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get CIDR mask, using default range, for this user </p>

</div>
</div>
<a class="anchor" id="a87a48da905cc1f023436a445d07ec878"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_connect_class.html">ConnectClass</a> * User::GetClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the connect class which this user belongs to. NULL for remote users. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to this user's connect class. </dd></dl>

<p>Reimplemented in <a class="el" href="class_local_user.html#aab46366cc609d9f341a50962ef1a2fce">LocalUser</a>.</p>

</div>
</div>
<a class="anchor" id="a242725aae6836377706ed4e202c5893e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; User::GetFullHost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the full displayed host of the user This member function returns the hostname of the user as seen by other users on the server, in nick!ident@host form. </p><dl class="section return"><dt>Returns</dt><dd>The full masked host of the user </dd></dl>

<p>Reimplemented in <a class="el" href="class_fake_user.html#a25d640886cf10c55d146cee889a206b6">FakeUser</a>.</p>

</div>
</div>
<a class="anchor" id="a1e57732a6d19e587c89e2b733796858c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; User::GetFullRealHost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the full real host of the user This member function returns the hostname of the user as seen by other users on the server, in nick!ident@host form. If any form of hostname cloaking is in operation, e.g. through a module, then this method will ignore it and return the true hostname. </p><dl class="section return"><dt>Returns</dt><dd>The full real host of the user </dd></dl>

<p>Reimplemented in <a class="el" href="class_fake_user.html#a7b472599a7864e55acdc659b0df0b537">FakeUser</a>.</p>

</div>
</div>
<a class="anchor" id="ab0806f9cdebcadc1718a20f849484f59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * User::GetIPString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get client IP string from sockaddr, using static internal buffer </p><dl class="section return"><dt>Returns</dt><dd>The IP string </dd></dl>

</div>
</div>
<a class="anchor" id="a7f7c295ff9e151bc52a8a5e9afc860f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool User::HasModePermission </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModeType&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true or false if a user can set a privileged user or channel mode. This is done by looking up their oper type from <a class="el" href="class_user.html#a968f02b552b0aac771aef8adac4f823e">User::oper</a>, then referencing this to their oper classes, and checking the modes they can set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The mode the check </td></tr>
    <tr><td class="paramname">type</td><td>ModeType (MODETYPE_CHANNEL or MODETYPE_USER). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the user can set or unset this mode. </dd></dl>

<p>Reimplemented in <a class="el" href="class_local_user.html#afb0c00147e85061e6079d21177251258">LocalUser</a>.</p>

</div>
</div>
<a class="anchor" id="ace6ae552be7ab53c3cbf83b63e4169c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool User::HasPermission </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true or false for if a user can execute a privilaged oper command. This is done by looking up their oper type from <a class="el" href="class_user.html#a968f02b552b0aac771aef8adac4f823e">User::oper</a>, then referencing this to their oper classes and checking the commands they can execute. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>A command (should be all CAPS) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this user can execute the command </dd></dl>

<p>Reimplemented in <a class="el" href="class_local_user.html#aba14c3dc45a9499c032cd86a8b5d3c86">LocalUser</a>.</p>

</div>
</div>
<a class="anchor" id="ad0fe27b1200383f282624cc8e9b2fa2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool User::HasPrivPermission </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>privstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noisy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if a user has a given permission. This is used to check whether or not users may perform certain actions which admins may not wish to give to all operators, yet are not commands. An example might be oper override, mass messaging (/notice $*), etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">privstr</td><td>The priv to chec, e.g. "users/override/topic". These are loaded free-form from the config file. </td></tr>
    <tr><td class="paramname">noisy</td><td>If set to true, the user is notified that they do not have the specified permission where applicable. If false, no notification is sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this user has the permission in question. </dd></dl>

<p>Reimplemented in <a class="el" href="class_local_user.html#a4654827b458b8ba164be532e1930a2a2">LocalUser</a>.</p>

</div>
</div>
<a class="anchor" id="a5d27df0379f0f7fc83de02b73673b1aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::InvalidateCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This clears any cached results that are used for <a class="el" href="class_user.html#a1e57732a6d19e587c89e2b733796858c">GetFullRealHost()</a> etc. The results of these calls are cached as generating them can be generally expensive. </p>

</div>
</div>
<a class="anchor" id="a45f8f16c80d3361f4df27faee248311f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool User::IsModeSet </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if a specific mode is set </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The user mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the mode is set </dd></dl>

</div>
</div>
<a class="anchor" id="a431867efdb64fc12b42fcfe405c8df17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool User::IsNoticeMaskSet </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if a notice mask is set </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>A notice mask character to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the notice mask is set </dd></dl>

</div>
</div>
<a class="anchor" id="adc1cc6d4dfc7d4e13ebb1071ad088196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; User::MakeHost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a usermask with real host. Takes a buffer to use and fills the given buffer with the hostmask in the format user@host </p><dl class="section return"><dt>Returns</dt><dd>the usermask in the format user@host </dd></dl>

</div>
</div>
<a class="anchor" id="a720f53db860db2bfdbc969d1ebcaa919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; User::MakeHostIP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a usermask with real ip. Takes a buffer to use and fills the given buffer with the ipmask in the format user@ip </p><dl class="section return"><dt>Returns</dt><dd>the usermask in the format user@ip </dd></dl>

</div>
</div>
<a class="anchor" id="a513647ef7789fdabf93ea71e9db0d685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * User::MakeWildHost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a wildcard host. Takes a buffer to use and fills the given buffer with the host in the format *!*@hostname </p><dl class="section return"><dt>Returns</dt><dd>The wildcarded hostname in *!*@host form </dd></dl>

</div>
</div>
<a class="anchor" id="af9b6ec0dae8b4ee90c0e13c2143622cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::Oper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_oper_info.html">OperInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Oper up the user using the given opertype. This will also give the +o usermode. </p>

</div>
</div>
<a class="anchor" id="a3d8a245fa3f3df4151e6601fcbf4da73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string User::ProcessNoticeMasks </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process a snomask modifier string, e.g. +abc-de </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>A sequence of notice mask characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cleaned mode sequence which can be output, e.g. in the above example if masks c and e are not valid, this function will return +ab-d </dd></dl>

</div>
</div>
<a class="anchor" id="a03321870943c66415b14404e31128090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::PurgeEmptyChannels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove this user from all channels they are on, and delete any that are now empty. This is used by QUIT, and will not send part messages! </p>

</div>
</div>
<a class="anchor" id="ad82af8e8e4af2129de781ccebc5abe21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::SendAll </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a command to all local users from this user The command given must be able to send text with the first parameter as a servermask (e.g. $*), so basically you should use PRIVMSG or NOTICE. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>the command to send </td></tr>
    <tr><td class="paramname">text</td><td>The text format string to send </td></tr>
    <tr><td class="paramname">...</td><td>Format arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09ba1522c6c1f87e20d6205fdb3f66a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::SendText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>LinePrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stringstream &amp;&#160;</td>
          <td class="paramname"><em>TextStream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump text to a user target, splitting it appropriately to fit </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LinePrefix</td><td>text to prefix each complete line with </td></tr>
    <tr><td class="paramname">TextStream</td><td>the text to send to the user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a089b36510ac944ed595089373fa7ea16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void User::SendText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write to the user, routing the line if the user is remote. </p>

<p>Implemented in <a class="el" href="class_fake_user.html#a3af3c3a77a39d1c602d6ffaff0ddccd9">FakeUser</a>, <a class="el" href="class_remote_user.html#a7dec7ec01e0cc40a6e01efc150e569b9">RemoteUser</a>, and <a class="el" href="class_local_user.html#aa0fa6bf2965c18296c3d75e0d6261b53">LocalUser</a>.</p>

</div>
</div>
<a class="anchor" id="aecc8bb0e3cd530e580184e724ab337fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::SendText </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write to the user, routing the line if the user is remote. </p>

</div>
</div>
<a class="anchor" id="af1f261163f93f5d70232d530c56a6cb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool User::SetClientIP </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recheck_eline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the client IP for this user </p><dl class="section return"><dt>Returns</dt><dd>true if the conversion was successful </dd></dl>

<p>Reimplemented in <a class="el" href="class_local_user.html#a3a2c4f40f4acb9e89f33a3c62e4c65ad">LocalUser</a>.</p>

</div>
</div>
<a class="anchor" id="a8dbebc71012c9e761b870f5dd9851e69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::SetMode </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a specific usermode to on or off </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The user mode </td></tr>
    <tr><td class="paramname">value</td><td>On or off setting of the mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c1bbc0d3005ba309d1a0572e4a88088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::SetNoticeMask </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changed a specific notice mask value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sm</td><td>The server notice mask to change </td></tr>
    <tr><td class="paramname">value</td><td>An on/off value for this mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a626bc5712170aa6ebad4c35153bb951e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool User::SharesChannelWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the user shares at least one channel with another user </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other user to compare the channel list against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given user shares at least one channel with this user </dd></dl>

</div>
</div>
<a class="anchor" id="a6876d094321ba00928b88e507df24cf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::SplitChanList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split the channel list in cl which came from dest, and spool it to this user Used internally by WHOIS </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The user the original channel list came from </td></tr>
    <tr><td class="paramname">cl</td><td>The channel list as a string obtained from <a class="el" href="class_user.html#a314dc765ce3fa346086e6164f3ed8831">User::ChannelList()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a326d5c537946b4f6c28c659675d1ed43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::UnOper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Oper down. This will clear the +o usermode and unset the user's oper type </p>

</div>
</div>
<a class="anchor" id="ac23112c612275acb529af30c2ff60515"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void User::Write </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write text to this user, appending CR/LF. Works on local users only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>A std::string to send to the user </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_local_user.html#a66cc1ddf9afde1b5830c1976b91de321">LocalUser</a>.</p>

</div>
</div>
<a class="anchor" id="a508ed8ff1be90f5b9e7437966dcf6f26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void User::Write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write text to this user, appending CR/LF. Works on local users only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The format string for text to send to the user </td></tr>
    <tr><td class="paramname">...</td><td>POD-type format arguments </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_local_user.html#a4dc140bbb0bfec7c269ea54c0687b55e">LocalUser</a>.</p>

</div>
</div>
<a class="anchor" id="a61fde66472ef2f5c79ccddc2f0c0e0c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::WriteCommon </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write to all users that can see this user (including this user in the list), appending CR/LF </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The format string for text to send to the users </td></tr>
    <tr><td class="paramname">...</td><td>POD-type format arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9aef1c4409bcf990abfdb19777d07369"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::WriteCommonExcept </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write to all users that can see this user (not including this user in the list), appending CR/LF </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The format string for text to send to the users </td></tr>
    <tr><td class="paramname">...</td><td>POD-type format arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a404c1c2ad7a87557661b8d9ec4271c9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::WriteCommonQuit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>normal_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oper_text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a quit message to all common users, as in <a class="el" href="class_user.html#a9aef1c4409bcf990abfdb19777d07369">User::WriteCommonExcept</a> but with a specific quit message for opers only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">normal_text</td><td>Normal user quit message </td></tr>
    <tr><td class="paramname">oper_text</td><td>Oper only quit message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b67ff8a39cf18ea837a56c3339f780a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::WriteCommonRaw </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_self</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write to all users that can see this user (including this user in the list if include_self is true), appending CR/LF </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>A std::string to send to the users </td></tr>
    <tr><td class="paramname">include_self</td><td>Should the message be sent back to the author? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51dbd8971acb541df15a28ccf50495f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::WriteFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write text to this user, appending CR/LF and prepending :nick!user@host of the user provided in the first parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user to prepend the :nick!user@host of </td></tr>
    <tr><td class="paramname">text</td><td>A std::string to send to the user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2b5476e24724e094e55009da9ae79dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::WriteFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write text to this user, appending CR/LF and prepending :nick!user@host of the user provided in the first parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user to prepend the :nick!user@host of </td></tr>
    <tr><td class="paramname">text</td><td>The format string for text to send to the user </td></tr>
    <tr><td class="paramname">...</td><td>POD-type format arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a601defc9871b1c57a9c61a26b22a97f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::WriteServ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write text to this user, appending CR/LF and prepending :server.name Works on local users only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>A std::string to send to the user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30a38a6346a80dc6c0e70689462c80ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::WriteServ </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write text to this user, appending CR/LF and prepending :server.name Works on local users only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The format string for text to send to the user </td></tr>
    <tr><td class="paramname">...</td><td>POD-type format arguments</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_user.html#a601defc9871b1c57a9c61a26b22a97f8">WriteServ()</a> Same as <a class="el" href="class_user.html#ac23112c612275acb529af30c2ff60515">Write()</a>, except `text' is prefixed with `:server.name '. </p>

</div>
</div>
<a class="anchor" id="aab99c4d21eea090aa8d2e6ec789a3ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::WriteTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write text to the user provided in the first parameter, appending CR/LF, and prepending THIS user's :nick!user@host. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The user to route the message to </td></tr>
    <tr><td class="paramname">data</td><td>A std::string to send to the user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78ebb40ba2e851126126013d73831968"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void User::WriteTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_user.html">User</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write text to the user provided in the first parameter, appending CR/LF, and prepending THIS user's :nick!user@host. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The user to route the message to </td></tr>
    <tr><td class="paramname">data</td><td>The format string for text to send to the user </td></tr>
    <tr><td class="paramname">...</td><td>POD-type format arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a6e62e3d0a124b4418891e11d76faad7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t User::age</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time that the object was instantiated (used for TS calculation etc) </p>

</div>
</div>
<a class="anchor" id="a9f4f7df5529c3547133907148fbb2918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string User::awaymsg</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The user's away message. If this string is empty, the user is not marked as away. </p>

</div>
</div>
<a class="anchor" id="aa0241e8f5196138096077725a628a476"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t User::awaytime</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time the user last went away. This is ONLY RELIABLE if user IS_AWAY()! </p>

</div>
</div>
<a class="anchor" id="a0f8babc78ccfb2f6aab5b4d4ecd274c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UserChanList User::chans</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Channels this user is on </p>

</div>
</div>
<a class="anchor" id="a118a42a76b20e6cb6de541d9e08041e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionirc_1_1sockets_1_1sockaddrs.html">irc::sockets::sockaddrs</a> User::client_sa</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Client address that the user is connected from. Do not modify this value directly, use <a class="el" href="class_user.html#af1f261163f93f5d70232d530c56a6cb2">SetClientIP()</a> to change it. Port is not valid for remote users. </p>

</div>
</div>
<a class="anchor" id="a8e572bdf54a71ea5b12365c4228c6731"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string User::dhost</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The host displayed to non-opers (used for cloaking etc). This usually matches the value of <a class="el" href="class_user.html#a7773fec016477ec1eba2f572b34eea76">User::host</a>. </p>

</div>
</div>
<a class="anchor" id="ae41b92b5c787bccfa3ff625de7522a07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int User::dns_done</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True when <a class="el" href="class_d_n_s.html">DNS</a> lookups are completed. The <a class="el" href="class_user_resolver.html">UserResolver</a> classes res_forward and res_reverse will set this value once they complete. </p>

</div>
</div>
<a class="anchor" id="a3c67c6d6e5d901d0b994e32bdb8ca7a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int User::exempt</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is true if the user matched an exception (E:Line). It is used to save time on ban checks. </p>

</div>
</div>
<a class="anchor" id="aa37f981a564b92cb131a4e62e2bd53df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string User::fullname</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The users full name (GECOS). </p>

</div>
</div>
<a class="anchor" id="a7773fec016477ec1eba2f572b34eea76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string User::host</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hostname of connection. This should be valid as per RFC1035. </p>

</div>
</div>
<a class="anchor" id="a75afe5805a15221777aaf204d99f17c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string User::ident</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The users ident reply. Two characters are added to the user-defined limit to compensate for the tilde etc. </p>

</div>
</div>
<a class="anchor" id="a249c29ce8508133303dfbe42ed2bf50f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t User::idle_lastmsg</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time that the connection last sent a message, used to calculate idle time </p>

</div>
</div>
<a class="anchor" id="a366e12fdc514b4ddf04441116cc1bbb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int User::lastping</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>has the user responded to their previous ping? </p>

</div>
</div>
<a class="anchor" id="afb1e528b004ddf33833323d4f4473cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::bitset&lt;64&gt; User::modes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The user's mode list. NOT a null terminated string. Also NOT an array. Much love to the STL for giving us an easy to use bitset, saving us RAM. if (modes[modeletter-65]) is set, then the mode is set, for example, to work out if mode +s is set, we check the field <a class="el" href="class_user.html#afb1e528b004ddf33833323d4f4473cb6">User::modes</a>['s'-65] != 0. The following RFC characters o, w, s, i have constants defined via an enum, such as UM_SERVERNOTICE and UM_OPETATOR. </p>

</div>
</div>
<a class="anchor" id="a6097de89cf5d8fd945c6782cfa7e89fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string User::nick</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The users nickname. An invalid nickname indicates an unregistered connection prior to the NICK command. Use <a class="el" href="class_insp_i_r_cd.html#a8bdc982e4c8a01f1cc2150d5df3c20a9">InspIRCd::IsNick()</a> to validate nicknames. </p>

</div>
</div>
<a class="anchor" id="a968f02b552b0aac771aef8adac4f823e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreference.html">reference</a>&lt;<a class="el" href="class_oper_info.html">OperInfo</a>&gt; User::oper</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The oper type they logged in as, if they are an oper. </p>

</div>
</div>
<a class="anchor" id="ace73638d21fef8d2785b3999a8abb149"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int User::quietquit</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether or not to send an snotice about this user's quitting </p>

</div>
</div>
<a class="anchor" id="a60f4fab44458bfa3e944a69c762c4273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int User::quitting</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this is set to true, then all socket operations for the user are dropped into the bit-bucket. This value is set by QuitUser, and is not needed seperately from that call. Please note that setting this value alone will NOT cause the user to quit. </p>

</div>
</div>
<a class="anchor" id="ac65949293e21924a52e5ff14f664129e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int User::quitting_sendq</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recursion fix: user is out of SendQ and will be quit as soon as possible. This can't be handled normally because QuitUser itself calls Write on other users, which could trigger their SendQ to overrun. </p>

</div>
</div>
<a class="anchor" id="a62fabba0257a3d6363d6f0159bba856c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int User::registered</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used by <a class="el" href="class_user.html">User</a> to indicate the registration status of the connection It is a bitfield of the REG_NICK, REG_USER and REG_ALL bits to indicate the connection state. </p>

</div>
</div>
<a class="anchor" id="ab07fe0b29d3b04bf886fb048e4796cbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string User::server</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The server the user is connected to. </p>

</div>
</div>
<a class="anchor" id="a1d50e3ac7bdcb5fb96d501d91782eb87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t User::signon</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time the connection was created, set in the constructor. This may be different from the time the user's classbase object was created. </p>

</div>
</div>
<a class="anchor" id="a98128434f41c8ca644ad0a2429565ef7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::bitset&lt;64&gt; User::snomasks</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>What snomasks are set on this user. This functions the same as the above modes. </p>

</div>
</div>
<a class="anchor" id="a982fa3195231117b83dde5b90ffd4685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int User::usertype</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>What type of user is this? </p>

</div>
</div>
<a class="anchor" id="a9ee4e34fd334d4b5f99fc1fa34b0155a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string User::uuid</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The user's unique identifier. This is the unique identifier which the user has across the network. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="users_8h_source.html">users.h</a></li>
<li>src/users.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
